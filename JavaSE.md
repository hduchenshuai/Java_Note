# Java 概述

## Java语言特点

1. 简单易学：Java语言的语法和C语言很相似，但是它去掉了C中的复杂的指针和多重继承等特性，使得Java语言更加简单易学。
2.  面向对象：Java语言是一种纯面向对象的编程语言，它支持对象的封装、继承和多态等面向对象的特性。 
3. **平台无关性（跨平台性：一次编译到处运行）：**Java语言的程序可以在不同的操作系统和硬件平台上运行，这是因为Java程序被编译成字节码，而不是机器码，字节码可以在任何支持Java虚拟机的平台上运行。 实现原理：不同的操作系统上安装属于自己的Java虚拟机，而Java虚拟机屏蔽了各个操作系统之间的差异，从而做到跨平台。
4. 安全性：Java语言具有很高的安全性，它提供了一系列的安全措施来保护程序不受恶意攻击和病毒侵害。 
5. 高性能：Java语言具有很高的性能，它采用了一系列优化措施来提高程序的执行速度和内存使用效率。 
6. 多线程支持：Java语言具有很好的多线程支持，它提供了一系列的线程控制机制，使得程序可以更好地利用计算机的多核处理能力。 
7. **自动垃圾回收机制：**Java语言采用的是垃圾回收机制（Garbage Collection，简称GC），也就是自动内存管理机制。在传统的编程语言中，程序员需要手动分配和释放内存，容易出现内存泄漏和悬挂指针等问题。而Java语言采用的垃圾回收机制可以自动分配和释放内存，避免了这些问题。

## Java运行机制

![e15b7502c68b7f1d8a6fb514bea52a2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031625623.png)

![image-20240716153738350](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407161537728.png)

* 包含两个阶段：编译阶段和运行阶段。

* 编译阶段和运行阶段可以在不同的操作系统上完成。

* 编译后删除java源程序，不会影响程序的执行。

* 生成的class文件如果是A.class，则类名为A。如果是Hello.class，则类名为Hello。

* javac是负责编译的命令。java是负责运行的命令。

* class文件不是机器码，操作系统无法直接执行。只有JVM才能看懂。

* JVM会把class字节码解释为机器码，这样操作系统才能看懂。

* JDK、JRE、JVM分别是什么？他们的关系是什么？

  ```
  JDK（Java Development Kit）：JDK 是 Java 开发⼯具包，包含了编写、编译、调试和运⾏ Java 程序所需的所有⼯具和组件，⽐如编译器（javac）、Java API、调试⼯具等。JDK 是针对 Java 开发⼈员的，它包含了JRE，还有编译器和其他⼯具，可以⽤来编写和调试 Java 程序。
  
  JRE（Java Runtime Environment）：JRE 是 Java 运⾏时环境，包括了 Java 虚拟机（JVM）和 Java 标准类
  库（Java API）。JRE 是针对 Java 应⽤程序的，它提供了在计算机上运⾏ Java 应⽤程序所需的最⼩环境。
  
  JVM（Java Virtual Machine）：JVM 是 Java 虚拟机，是 Java 程序运⾏的环境。JVM 负责将 Java 代码解释或编译为本地机器代码，并在运⾏时提供必要的环境⽀持，⽐如内存管理、垃圾回收、安全性等。JVM 的主要作⽤是将 Java 代码转换为可以在计算机上运⾏的机器码，并负责程序的执⾏。
  
  综上所述，JDK、JRE 和 JVM 之间的区别可以总结如下：
  JDK = JRE + Java开发工具
  JRE = JVM + Java核心类库
  ```



## 环境变量CLASSPATH

- classpath环境变量是隶属于Java语言的。不是windows操作系统的。和PATH环境变量完全不同。

- classpath环境变量是给classloader（类加载器）指路的。

- java A。执行后。先启动 JVM，JVM启动classloader，classloader去硬盘上通过classpath找A.class文件。找到则执行，找不到则报错。

- 如果classpath没有配置的话，默认从当前路径下找class字节码文件。

- 如果classpath配置了，例如配置到桌面上了：‪C:\Users\HP\OneDrive\Desktop，那么classloader以后就只会去桌面上找字节码文件了，不再从当前路径下找了。![00454c993fec516a9f7c424b56b140c](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407161734372.png)

  

- 注意，如果classpath配置为：classpath=.;‪C:\Users\HP\OneDrive\Desktop 是什么意思呢？

  - 先让类加载器从当前路径下找，如果找不到的话，去‪C:\Users\HP\OneDrive\Desktop找。

  

## Public class 与 class 的区别

```java
/**
* java语言严格区分大小写
* 一个源文件中最多只能有一个public类。其他类的个数不限。编译后，每一个类都对应一个.class文件
* public的类可以没有，有的话，只能有一个，并且public的类名要和源文件名保持一致
* 任何一个class中都可以有main方法，但对于一个软件来说，一般入口只有一个
* public static void main(String[]arg)是固定的书写格式 表示一个主方法，即程序的入口
*/
public class Hello{
	public static void main(String[]arg){
		System.out.println("hello,world~");
	}
}
```



# Java基础语法

## 标识符

### 什么是标识符？

在Java中，标识符是用来给变量、方法、类和包等命名的字符序列

标识符的长度没有限制，但是建议使用有意义的、简洁的标识符，以提高代码的可读性和可维护性

### 标识符可以标识什么？

1. 变量名
2. 方法名
3. 类名、接口名、枚举名、注解名
4. 包名
5. 常量名
6. ......

### 标识符命名规则

1. 标识符可以由**字母**、**数字**、下划线(**_**)和美元符号(**$**)组成，不能含有其他符号。（java支持全球所有语言，所以这里的 字母 指的是任何一个国家的文字都可以）
2. 标识符**不能以数字开头**。
3. 标识符不能是Java中的关键字，如public、class、void等。
4. 标识符是区分大小写的，即Foo和foo是两个不同的标识符。
5. 标识符的长度没有限制，但是Java建议使用有意义的、简短的标识符

### 标识符命名规范

1. 见名知意
2. 驼峰式命名方式
3. 类名、接口名、枚举、注解：首字母大写，后面每个单词首字母大写。（StudentService，UserService）
4. 变量名和方法名：首字母小写，后面每个单词首字母大写。（doSome，doOther）
5. 常量名：全部大写，每个单词用下划线连接。（LOGIN_SUCCESS，SYSTEM_ERROR）
6. 包名：全部小写

## 关键字

* Java关键字是Java编程语言中预定义的具有特殊含义的单词，这些单词不能被用作标识符，而是在语法中有特定的用法和限制。
* Java关键字都是小写的
* 48个关键字+2个保留字（Java中还没用到但也不让我们用）：
  * abstract, assert, boolean, break, byte, case, catch, char, class, continue, default, do, double, else, enum, extends, final, finally, float, for, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
  * 保留字：goto，const

## 字面量

* 字面量指的是在程序中直接使用的数据，字面量是Java中最基本的表达式，不需要进行计算或转换，直接使用即可。
* Java中有哪些字面量？
  * 整数型：10、-5、0、100
  * 浮点型：3.14、-0.5、1.0
  * 布尔型：true、false
  * 字符型：'a'、'b'、'c'、'1'、'2'、'国'
  * 字符串型："Hello"、"World"、"Java"、"你好呀"

## 变量

### 变量概述

* 变量是内存当中的一块空间。是计算机中存储数据最基本的单元。

* 变量三要素

  * 数据类型（决定空间大小）【int, double, String】

  * 变量名（只要是合法的标识符即可）

  * 变量值（变量中具体存储的数据）

* 变量的声明、赋值、访问

  ```java
  int i; // 声明一个整数型的变量，起名i
  
  i = 100; // 给变量i赋值100
  
  System.out.println(i); // 访问i变量：读操作
  
  i = 200; // 访问i变量：改操作【给变量i重新赋值200】
  ```

### 变量细节

* 变量必须先声明，再赋值，才能访问

* 方法体当中的代码遵循自上而下的顺序依次逐行执行，变量先访问，再声明肯定是不行的

* 一行代码上可以同时声明多个变量

  ```java
  int a, b, c;
  int a = 1, b = 2, c = 3;
  int a, b, c = 1; //表示声明三个int类型的变量a,b,c,其中a和b没有赋值，c赋值1
  ```

* 在同一个作用域当中，变量名不能重名，可以重新赋值

* 变量值的数据类型必须和变量的数据类型一致，这样是不允许的：String name = 100;

### 变量的作用域

①作用域就是变量的有效范围。在java程序中通常是一个{}对应一个作用域，出了大括号就不认识了。

②作用域的不同主要是因为声明在不同位置的变量具有不同的生命周期。所谓的生命周期是：从内存开辟到内存释放。

③Java遵循就近原则

### 变量的分类

* 局部变量

* 成员变量
  * 静态变量
  * 实例变量

## 数据类型

### 概述

![image-20240716213541185](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407162135397.png)

![image-20240716213633327](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407162136972.png)

关于默认值：Java语言中变量必须先声明，再赋值，才能使用。对于局部变量来说必须手动赋值，而对于成员变量来说，如果没有手动赋值，系统会自动赋默认值。

### 整数型详解

#### 整数型字面量的四种表示形式

1. 十进制表示法：以数字0-9组成的常数，默认为十进制表示法。

例如：int a = 10;

2. 二进制表示法：以0b或0B开头的常数，由0和1组合而成。

例如：int b = 0b101;

3. 八进制表示法：以0开头的常数，由数字0-7组成。

例如：int c = 012;

4. 十六进制表示法：以0x或0X开头的常数，由0-9和A-F（大小写均可）组成。

例如：int d = 0x1F;

#### 整数型字面量默认当做int处理

Java中整数型字面量默认被当做int类型来处理，如果要表示long类型的整数，需要在字面量后面加上'L'或'l'标记。例如，下面是表示int和long类型整数的字面量的示例：

int x = 10; // 10是一个int类型的字面量

long y = 10L; // 10L是一个long类型的字面量

需要注意的是，大小写字母'L'和'l'的使用没有区别，但是容易被误解为数字1，因此建议使用大写字母。

```java
long z = 2147483648;//编译报错，原因是2147483648被当做int类型处理，而该数字本身已经超出了int最大值
long z = 2147483648L;// 正确
```

#### 自动类型转换

在Java中，对于基本数据类型来说，小容量是可以直接赋值给大容量的，这被称为自动类型转换。对于数字类型来说大小关系为：**byte < short < int < long < float < double**

#### 强制类型转换

①Java中大容量是无法直接转换成小容量的。因为这种操作可能会导致精度损失，所以这种行为交给了程序员来决定，当然这种后果自然是程序员自己去承担。因此在代码中需要程序员自己亲手加上强制类型转换符，程序才能编译通过

②强制类型转换时，底层二进制是如何变化的？原则：砍掉左侧多余的二进制。

③强制类型转换时，精度可能会损失，也可能不会损失，这要看具体的数据是否真正的超出了强转后的类型的取值范围。

#### 当整数字面量没有超出byte的范围

①在Java中有这样一个规定，当整数型字面量没有超出byte的范围：可以直接赋值给byte类型的变量。

byte b = 127; // 这是允许的

很显然，这是一种编译优化。同时也是为了方便程序员写代码。

②如果超出了范围，例如：

byte b = 128; // 编译报错

这样就会报错，需要做强制类型转换，例如：

byte b = (byte)128;

③在整数类型中，除了byte有这个待遇之外，short同样也是支持的。也就是说：如果整数型字面量没有超出short取值范围时，也是支持直接赋值的。

### 浮点型详解

#### 浮点型字面量默认被当做double

Java中，浮点型字面量默认被当做double类型，如果要当做float类型，需要在数字后面添加 F 或 f。

float f = 3.0; // 编译报错

报错原因是：3.0默认被当做double类型，大容量无法直接赋值给小容量。如何修改：

float f = 3.0F;

#### 浮点型数据两种表示形式

①第一种形式：十进制

double x = 1.23;

double y = 0.23;

double z = .23;

②第二种形式：科学计数法

double x = 0.123E2; // 0.123 * 10的平方

double y = 123.34E-2; // 123.34 / 10的平方

#### 浮点型数据存储原理

①符号位：0表示整数。1表示负数。

②指数位：比如小数0.123E30，其中30就是指数。表示0.123 * 10的30次幂。所以也有把指数位叫做偏移量的。最大偏移量127。

③尾数位：浮点数的小数部分的有效数字。例如：0.00123，那么尾数位存储123对应的二进制。

④从浮点型数据存储原理上可以看到，二进制中的指数位决定了数字呈指数级增大。因此float虽然是4个字节，但却可以表示比long更大的数值。因此float容量比long的容量大。

![image-20240716230842075](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407162308307.png)

#### 浮点型数据使用注意事项

一旦有浮点型数据参与运算得出的结果，一定不要使用“==”与其它数字进行“相等比较”

```java
不要这样：
double x = 6.9;
double y = 3.0;
double z = x / y;

if(z == 2.3){
  System.out.println("相等");
}

可以这样：
double x = 6.9;
double y = 3.0;
double z = x / y;

if(z - 2.3 < 0.000001){
  System.out.println("相等");
}
```

### 字符型详解

#### 字符型char细节

* 占用两个字节，0~65535，和short容量相同，但char可以取更大的整数

* 单个字符，使用单引号括起来，不能是多个字符，不能用双引号

* 可以保存一个汉字

* char c = ''; 这是不允许的

* char c = ‘\u0000’; 这表示一个空字符，也是char的默认值。\u0000是一个Unicode码。

* 空字符与空格字符是不同的。空字符表示什么也没有。空格字符表示一个空格。

* Java中允许将一个整数赋值给char类型变量，但这个整数会被当做ASCII码值来处理，这个码值有要求，不能超出char的取值范围

  ```java
  char c = 97;
  System.out.println(c);//a
  ```

* 只要没有超出byte、 short、 char的取值范围，是可以直接赋值给byte、 short、 char类型变量的

* byte、 short、 char混合运算时，各自会先转换成int再做运算!

  ```java
  byte b = 1;
  short s = 1;
  char c = 1;
  int num = b + s + c;
  System.out.println(num);//3
  ```

  ```java
  System.out.println('a' + 1);//98
  ```

  ```java
  char c = 'a' + 1;
  System.out.println(c);//b
  解释：运算时字符a自动转换成int类型的97，运算后是int的98，赋给c,打印时98被当做ASCII码值来处理，输出b
  ```

* 多种数据类型混合运算时，各自转成最大的再做运算

#### 转义字符

①`\t`: 表示制表符，相当于按下 Tab 键

②`\n`: 表示换行符

③`\"`: 表示双引号（"）

④`\'`: 表示单引号（'）

⑤`\\`: 表示反斜线（\）本身

#### 字符编码

①字符编码是人为规定的文字与二进制之间的转换关系。

②在早期计算机系统中，字符编码主要采用的是 ASCII 编码，采用1个字节编码。最多可以表示256个字符。（实际上ASCII码表只用了128个。），程序员需要记住这几个:

a 对应ASCII码 97（b是98，以此类推）

A 对应ASCII码 65（B是66，以此类推）

0 对应ASCII码 48（1是49，以此类推)

![image-20240716231523056](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407162315602.png)

**什么是编码？什么是解码？乱码是怎么产生的？**

①字符在计算机系统中，解码（Decoding）和编码（Encoding）是两个常用的概念，分别表示将二进制数据转换为字符和将字符转换为二进制数据。

②编码是将字符转换为二进制数据的过程。解码是将二进制数据转换为字符的过程。例如：

'a' ---------按照ASCII码表编码-----------> 01100001

01100001 --------按照ASCII码表解码------------> 'a'

③乱码是指在字符编码和解码的过程中，由于编码和解码所采用的字符集不一致，或者编码和解码所采用的字符集不支持某些字符，导致最终显示的字符与原始字符不一致。为了避免乱码的问题，我们需要统一使用一个字符集，并且在进行字符编码和解码时要保持一致。

**常见的字符编码**

1. **ASCII 编码**（American Standard Code for Information Interchange：美国信息交换标准编码）：采用1个字节编码，包括字母、数字、符号和控制字符等。 

2. ②Latin-1编码（ISO 8859-1），采用1个字节编码。该编码方式是为了表示欧洲语言（如荷兰语、西班牙语、法语、德语等）中的字符而设计的，共支持 256 个字符。

3. ANSI 编码（American National Standards Institute：美国国家标准协会）：采用1个字节编码，支持英文、拉丁文等字符。两个ANSI码可以表示一个汉字。 

4. **Unicode 编码**：可表示所有语言的字符。采用了十六进制表示，占用 2 个字节或 4 个字节，最多可表示超过一百万个字符。 （使用这种方式是有点浪费空间的，例如英文字符'a'其实采用一个字节存储就够了。）

5. **UTF-8 编码**（Unicode Transformation Format，8-bit）：基于 Unicode 编码的可变长度字符编码，能够支持多语言和国际化的需求，使用 1~4 个字节来表示一个字符，是目前 Web 开发中最常用的字符编码方式。 （一个英文字母1个字节，一个汉字3个字节。）

6. UTF-16 编码：基于 Unicode 编码的可变长度字符编码，使用 2 或 4 个字节来表示一个字符，应用于很多较早的系统和编程语言中。 （一个英文字母2个字节。一个汉字4个字节。）

7. UTF-32编码：基于Unicode编码的固定长度字符编码，其特点是每个字符占用4个字节。

8. GB2312 编码（小）：是中国国家标准的简体中文字符集，使用 2 个字节来表示一个汉字，是 GBK 编码的前身。 

9. GBK 编码（Guo Biao Ku）（中）：是针对中文设计的一个汉字编码方式，使用 2 个字节来表示一个汉字，能够表示中国内地的所有汉字。 

10. GB18030编码（大）：是中国国家标准GB 18030-2005《信息技术 中文编码字符集》中规定的字符集编码方案，用于取代GB2312和GBK编码。

每种编码方式都有其特点和适用场景。在进行软件开发、网站开发和数据存储时，需要根据实际情况选择适合的编码方式。

### boolean类型

* boolean类型只有两个值：true、false。没有其它值，**没有0和1这一说**。

* 通常用于表示一些逻辑上的真假值，并在程序中进行逻辑控制，例如以下代码：

```java
boolean gender = true;

if(gender){
  System.out.println("男");
}else{
  System.out.println("女");
}
```

### 基本数据类型转换规则

* 八种基本数据类型，除布尔型之外，其它类型都可以互相转换。

* 小容量转换为大容量，叫做自动类型转换，容量从小到大的排序为：
  * byte < short(char) < int < long < float < double
  * 注意char比short可以表示更大的整数

* 大容量转换为小容量，叫做强制类型转换，需要加强制类型转换符才能编译通过，运行时可能损失精度，也可能不会损失。

* 整数字面量如果没有超出byte short char的取值范围，可以直接赋值给byte short char类型的变量。

* byte short char混合运算，各自先转换为int再做运算。

* 多种类型混合运算，各自先转换成容量最大的类型，再做运算

## 运算符

### 接收用户键盘输入

```java
public class KeyInput{
	public static void main(String[] args){
		
		// 创建一个键盘扫描器对象 s
		java.util.Scanner s = new java.util.Scanner(System.in);

		System.out.print("请输入一个数字：");

		// 程序执行到这里就会停下来，等待键盘的输入。键盘如果没有输入，这里就会一直卡着。
		// 直到用户输入了内容之后，敲回车，这行代码就执行结束了。
		// s.nextInt()会专门从键盘上扫描int类型的数字，然后将扫描到的int数字赋值给num变量。
		// 这样就完成了数据从控制台到内存。
		// 针对nextInt()方法来说，只能接收整数数字。输入其他的字符串会报错。
		int num = s.nextInt();

		System.out.println("您输入的数字是：" + num);

		System.out.print("请输入一个浮点型数据：");

		// 想从键盘上接收一个double类型的数据。
		// 执行到这里会停下来，等待用户的输入。
		double num2 = s.nextDouble();
		System.out.println("您输入的这个浮点数据是：" + num2);


		System.out.print("请输入您的尊姓大名：");
		// 从键盘上接收一个字符串，但是接收的是第一个空格之前的内容。
		// 程序执行到这里，等待用户的输入。
		String username = s.next();
		System.out.println("欢迎您" + username);

		System.out.print("请输入您的真实姓名：");
		// 从键盘上接收一个字符串，但是接收的是第一个换行符\n之前的内容。
		s.nextLine(); // 如果在使用该方法之前执行过next,nextInt等方法，第一次调用这个方法是读取缓存中遗留的 \r 回车符。独立使用该方法则不需要执行两次
		String name = s.nextLine(); // 第二次调用这个方法才会真正的接收用户的输入。
		System.out.println("欢迎您" + name);
	}
}
```



### 算术运算符

```
+ ： 求和，字符串拼接，正数
- ： 相减，负数
* ： 乘积
/ ： 商（除以）
% ： 取模（求余数）
        取模公式：x - x / y * y
++ ：让变量自身加1
-- ：让变量自身减1
```

```
++ 自加1
-- 自减1

1. ++ 可以出现在变量前，也可以出现在变量后。
    ++i; 可以
    i++; 也可以

    像++这种运算符，只有一边有操作数，我们把这种运算符称为：一元运算符。

    a + b，这里的+两边有两个操作数，所以这种运算符被称为：二元运算符。

2. 无论++出现在变量前，还是变量后，执行结束后，都会让变量中的值自加1.

3. 当 ++ 出现在变量后？
    先赋值后自加1

4. 当 ++ 出现在变量前？
    先自加1后赋值。
```

**字节码角度深度解读**：

![image-20240717110648552](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407171106016.png)

```xml
查看字节码的命令是：javap -c xxx.class

bipush指令：将字面量压入操作数栈
istore_1指令：将操作数栈中顶部数据弹出，然后将该数据存放到局部变量表的第1个位置
iload_1指令：将局部变量表1号槽位的数据压入操作数栈
iinc指令：将局部变量表中第1个位置数据加1

在java语言中，任何一个方法执行时，都会专门为这个方法分配所属的内存空间。供这个方法使用。
每个方法都有自己独立的内存空间。这个内存空间中有两块比较重要的内存空间：
一块叫做：局部变量表（存储局部变量的。）
另一块叫做：操作数栈（存储程序运行过程中参与运算的数据）
```

```java
/*
*  i++字节码解读
*/
public class ReadClass04{
	public static void main(String[] args){
		int i = 10;
		int j = i++;
	}
}

/*
Compiled from "ReadClass04.java"
public class ReadClass04 {
  public ReadClass04();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: bipush       10    //操作数栈压入10
       2: istore_1			 //弹出10 ，存放在局部变量表第一个位置(i=10)
       3: iload_1			 //将局部变量表1号槽位的数据 10 压入操作数栈
       4: iinc         1, 1  //局部变量表第一个位置数据加1，即1号槽位存的11(i=11)
       7: istore_2			 //将操作数栈中顶部数据10弹出，然后将该数据存放到局部变量表的2号槽位(j=10)
       8: return
}
*/
```

```java
/*
*  ++i字节码解读
*/
public class ReadClass05{
	public static void main(String[] args){
		int i = 10;
		int j = ++i;
	}
}
/*
Compiled from "ReadClass05.java"
public class ReadClass05 {
  public ReadClass05();
    Code:
       0: aload_0
       1: invokespecial #1                  // Method java/lang/Object."<init>":()V
       4: return

  public static void main(java.lang.String[]);
    Code:
       0: bipush        10    //操作数栈压入10
       2: istore_1			  //弹出10 ，存放在局部变量表第一个位置(i=10)
       3: iinc          1, 1  //局部变量表第一个位置数据加1，即1号槽位存的11(i=11)
       6: iload_1			  //将局部变量表1号槽位的数据 11 压入操作数栈
       7: istore_2			  //将操作数栈中顶部数据11弹出，然后将该数据存放到局部变量表的2号槽位(j=11)
       8: return
}
*/
```

**面试题**

```java
int i = 10;
int k = i++ + ++i;
System.out.println(k); // 22

解析：int k = ?1 + ?2
     ?1 = i++; // ?1 = 10; i = 11;
	 ?2 = ++i; //此时i已经是11，再++变成12，赋给?2
	 故int k = ?1 + ?2 = 10 + 12 
----------------------------------------------------          
int f = 10;
int m = f++ + f;//同理 m = 10 + 11
System.out.println(m); // 21
System.out.println(f); // 11
----------------------------------------------------   
int i = 10;
i = i++;
System.out.println(i);//10
解析：i = i++;底层原理相当于：
    int temp = i;
	i++;
	i = temp;
----------------------------------------------------
int i = 10;
i = ++i;
System.out.println(i);//11
```

### 关系运算符

* 关系运算符又叫做比较运算符。包括：>、 >=、 <、 <=、 ==、 !=
* 所有关系运算符的运算结果都是布尔类型，不是true，就是false。

### 逻辑运算符

* 逻辑运算符：&（逻辑与）、 |（逻辑或）、 !（逻辑非）、^（逻辑异或）、 &&（短路与）、 ||（短路或）
* 逻辑运算符特点：逻辑运算符两边的操作数要求必须是布尔类型，并且最终运算结果也一定是布尔类型。
* 逻辑与&：两边操作数都是true，结果才是true。可以翻译为“并且”。
* 逻辑或|：两边操作数只要有一个是true，结果就是true。可以翻译为“或者”。
* 逻辑非!： !false就是true，!true就是false。
* 逻辑异或^：咱俩不一样，结果就是true。
* 短路与&&：和逻辑与&的运算结果相同。只是存在一种短路现象。（左边操作数为false时，右边操作数不执行）
* 短路或||：和逻辑或|的运算结果相同。只是存在一种短路现象。（左边操作数为true时，右边操作数不执行）
* 虽然短路与&&效率高于逻辑与&，但逻辑与&也有用武之地，具体看需求是怎样的。

### 按位运算符

* 按位运算符用于在二进制位级别上处理整数数据。主要包括：

- 左移 <<
- 右移 >>
- 无符号右移 >>>
- 按位与 &
- 按位或 |
- 按位异或 ^
- 按位取反 ~

注意：按位运算符的操作数要求必须是整数。否则会出现编译错误



**左移 <<**

```java
/*
	按位运算符：
		1. 左移运算符 <<

		2. 规则：
			左移n位，结果是乘以2的n次方。
		
		3. 溢出的会被截断。右侧补0.

		4. 左移的时候符号位不变。

		5. 注意：任何位运算符，操作的都是补码。
*/
public class OperatorTest05{
	public static void main(String[] args){
		
		/*
			原码：00000000 00000000 00000000 00000001
			反码：00000000 00000000 00000000 00000001
			补码：   00000000 00000000 00000000 00000001
			左移3位：00000 00000000 00000000 00000001000（补码）
		*/
		int a = 1;
		System.out.println(a << 3); // 8（1 * 2的3次方）
		
		/*
			原码：00000000 00000000 00000000 10000000
			反码：00000000 00000000 00000000 10000000
			补码：   00000000 00000000 00000000 10000000
			左移2位：000000 00000000 00000000 1000000000
		*/
		int b = 128;
		System.out.println(b << 2); // 512（128 * 2的2次方）

		
		/*
			原码：10000000 00000000 00000000 01100100
			反码：11111111 11111111 11111111 10011011
			补码：   11111111 11111111 11111111 10011100
			左移2位：111111 11111111 11111111 1001110000（补码）
			原码：   100000 00000000 00000000 0110010000
		*/
		int c = -100;
		System.out.println(c << 2); // -400（-100 * 2的2次方）


		/*
			经典面试题：怎么让2快速变成8？
		*/
		int x = 2;

		//System.out.println(x * 4);

		System.out.println(x << 2);

	}
}
```



**右移 >>**

```java
/*
右移运算符 >>

	它能够将一个二进制数的所有位向右移动指定的位数。右移运算符的运算规则如下：

		1. 将二进制数右移n位，相当于将数值除以2的n次方。

		2. 右移运算符对正数、负数和零的处理方式不同。
			对于正数，符号位不变，右移时左补0
			对于负数，符号位不变，右移时左补1。
			对于零，右移运算符操作后结果仍为零。

		3. 右移运算符会对溢出进行截断。

*/
public class OperatorTest06{
	public static void main(String[] args){
		/*
			原码：00000000 00000000 00000000 00000001
			反码：00000000 00000000 00000000 00000001
			补码：   00000000 00000000 00000000 00000001
			右移1位：000000000 00000000 00000000 0000000
		*/
		int a = 1;
		System.out.println(a >> 1); // 0

		/*
			00000000 00000000 0000000 10000000
			000000000000 00000000 0000000 1000
		*/
		int b = 128;
		System.out.println(b >> 4); // 8

		/*
			原码：10000000 00000000 00000000 10000000
			反码：11111111 11111111 11111111 01111111
			补码：11111111 11111111 11111111 10000000
			右移：111111111111 11111111 11111111 1000（补码）
			原码：100000000000 00000000 00000000 1000
		*/
		int c = -128;
		System.out.println(c >> 4); // -8
	}
}
```

**无符号右移：>>>**

它能够将一个二进制数的所有位向右移动指定的位数，而不考虑符号位。无符号右移运算符的运算规则如下：

1. 将二进制数右移n位，相当于将数值除以2的n次方，并将最高位填充为0。
2. 任意一个数字经过无符号右移之后，最终结果一定是非负数（0或正整数）
3. 无符号右移运算符对溢出进行截断。

```java
/*
无符号右移：>>>
	1. 溢出后的截断。
	2. 无符号右移之后，最终的结果一定是0或者正整数。
	3. 无符号右移之后，左侧补0.（不管是正数还是负数，都是补0）
*/
public class OperatorTest07{
	public static void main(String[] args){
		
		/*
			原码：10000000
			反码：11111111
				  10000000（补码）
			      00100000（无符号右移2位）
		*/
		byte b = -128;
		
		/*
			为什么输出结果不是32？
				b >>> 2。
				byte和int混合运算。会先将byte转换成int，再做运算。
			
			int b = -128;
			原码：10000000 00000000 00000000 10000000
			反码：11111111 11111111 11111111 01111111
			补码：11111111 11111111 11111111 10000000
			右移：0011111111 11111111 11111111 100000（补码）
		*/
		//System.out.println(b >>> 2); // 1073741792

		//System.out.println(0b00111111111111111111111111100000); // 1073741792

		// 11100000（补码）
		// 10100000（原码）
		System.out.println((byte)(b >>> 2)); // -32

		/*
			原码：10000000 00000000 00000000 01011010
			反码：11111111 11111111 11111111 10100101
			补码：11111111 11111111 11111111 10100110
			右移：00011111111 11111111 11111111 10100
		*/
		int x = -90;
		System.out.println(x >>> 3);
		System.out.println(0b00011111111111111111111111110100);

		/*
			00000000 00000000 00000000 01011010
			00000000000 00000000 00000000 01011
		*/
		int y = 90;
		System.out.println(y >>> 3); // 11
	}
}
```

**按位与 &**

* 将两个整数的二进制表示按位进行与运算
  * 1&1 -> 1
    1&0 -> 0
    0&1 -> 0
    0&0 -> 0
* 怎么判断一个数字是否为奇数？
  * 第一种方式：对2取模，结果不等于0，表示奇数。
  * 第二种方式：让这个数字和1进行按位与操作，结果是1，表示是奇数。

**按位或 |**

* 将两个整数的二进制表示按位进行或运算
  * 1|0 -> 1
    0|1 -> 1
    1|1 -> 1
    0|0 -> 0
* 按位或的具体应用：将某个二进制位设置为1

**按位异或 ^**

* 将两个整数的二进制表示按位进行异或运算，只有当相应的二进制位不同，结果才为1，否则结果为0
  * 1 ^ 1 -> 0
    0 ^ 0 -> 0
    1 ^ 0 -> 1
    0 ^ 1 -> 1

* 按位异或运算符具有自反性：
  * a ^ b ^ b ==> a
  * 所谓的自反性是指：数字A连续对数字B进行两次按位异或运算之后，可以得到原始的数字A。因为按位异或运算符具有这样的特征，所以在密码学方面应用广泛。通常使用它可以完成加密和解密操作。

**按位取反 ~**

* 将整数的二进制表示按位进行取反运算，即0变为1，1变为0

  System.out.println(~100); // -101

  100的二进制：01100100

  取反后：10011011（这是一个补码哦）

  将补码转为原码：11100101 （-101）

* 应用：位清除操作（将某个二进制位中指定位清除为0），例如有这样一个二进制：0b01101101，将第4个低位清除为0

  int value = 0b01101101;// 待清除数据

  int flag = 1 << 3; // 需要清除第4个低位

  int result = value & (~flag);// 使用这种方式运算进行位清除

### 赋值运算符

**基本赋值运算符**

* = 等号右边先执行，将直接结果赋值给左边的变量

**扩展赋值运算符**

* +=、-=、*=、/=、%=、&=、|=、^=、>>=、<<=、>>>=

* 以 += 为例。i += 3; 表示 i = i + 3;

* += 就是先+后=，也就是先求和，然后将求和的结果重新赋值。

* 对于扩展赋值运算符来说，有一个非常重要的运算规则需要注意：扩展赋值运算符不会改变运算结果的类型。（即使精度损失了，也不会改变运算结果类型。）

  * ```java
    /*
        i += 10; 和 i = i + 10; 完全一样吗？
            i += 10; 自带强制类型转换。
            i = i + 10; 没有强制类型转换。
    */
    byte m = 10;
    
    m = m + 20;// 错误: 不兼容的类型: 从int转换到byte可能会有损失
    
    m += 20; // 底层实际上对应的是：m = (byte)(m + 20);
    ```

### 条件运算符

* Java 语言中的条件运算符由 ? 和 : 组成，也被称为三元运算符。它的语法格式为：

  布尔表达式 ? 表达式1 : 表达式2

* 当布尔表达式的值为 true 时，条件运算符的结果为表达式1的值，否则为表达式2的值。这种运算符常用于简化 if-else 语句的代码量。

* 下面是一个条件运算符的简单示例：

  int a = 5, b = 7;

  int max = (a > b) ? a : b;

  System.out.println("最大值为：" + max);

  在上述代码中，首先定义了两个变量 a 和 b，然后使用条件运算符比较这两个变量的大小，取其中较大值作为变量 max 的值，最后输出结果。当 a > b 的结果为 false 时，条件运算符的结果为表达式2，即 b 的值为变量 max 的值。当 a > b 的结果为 true 时，条件运算符的结果为表达式1，即 a 的值为变量 max 的值。

* 总的来说，条件运算符在 Java 中的使用相对简单，能够减少代码重复和代码量，常用于简单的条件处理和表达式值的判断

  

## 程序控制语句

控制语句：用于控制程序的执行流程，改变程序执行的次序

### 分支语句

#### if语句

* if语句的四种写法

  * ```java
    if语句的第一种写法：
        
    if(布尔表达式){
    	分支语句;
    }
    
    如果布尔表达式true，则执行分支语句。如果为false，则不执行。
    如果 {} 中只有一条语句，可以省略 {} 
    ```

  * ```java
    if语句的第二种写法：
    
    if(布尔表达式){
    	分支1;
    }else{
    	分支2;
    }
    
    如果布尔表达式true，则执行分支1。如果为false，则执行分支2。
    ```

  * ```java
    if语句的第三种写法：
    
    if(布尔表达式){
    	分支1;
    }else if(布尔表达式){
    	分支2;
    }else if(布尔表达式){
    	分支3;
    }
    从上往下依次判断布尔表达式，只要遇到布尔表达式为true，则执行对应的分支，整个if结束。如果都是false，没有分支执行。
    ```

  * ```java
    if语句的第四种写法：
    
    if(布尔表达式){
    	分支1;
    }else if(布尔表达式){
    	分支2;
    }else if(布尔表达式){
    	分支3;
    }else{
    	分支4;
    }
    
    从上往下依次判断布尔表达式，只要遇到布尔表达式为true，则执行对应的分支，整个if结束。如果都是false，则执行最后的else分支。
    ```

* if语句的使用注意事项：
  * 对于任何一个if语句来说，最多只能有一个分支执行。
  * 分支中如果只有一条Java语句，大括号可以省略。
  * 对于以上第2种和第4种，这两种写法是可以保证一定会有一个分支执行的。因为这两种写法都有else分支。
  * 对于以上第1种和第3种，这两种写法可能会没有分支执行。
  * 在if选择结构中还可以嵌套别的选择结构或循环结构。



####  switch语句

* switch语句语法格式：

```java
switch(表达式){
        
    case value 1:
        语句块1;
        break;
        
    case value 2:
        语句块2;
        break;
    
  	    ...
        
    case value n:
        语句块n;
        break;
        
    default:
        default语句块;
        break;             
        
}
```

* switch语句使用注意事项：

  * switch 语句适用于判断固定值。if语句适用于判断范围或区间时使用。switch能做的if肯定能做，if能完成的switch不一定能完成。 

  * 表达式返回一个值，这个值按顺序与case 语句中的值匹配，匹配成功就执行相应语句，如果一个都没匹配上，则执行 default 语句块

  * 表达式最后执行完是一个值，这个值要求类型是：int，枚举类型，字符串类型。当然，也可以直接把byte short char放进去，会进行自动类型转换成int类型。

  * break;语句只要执行，switch语句就会结束。

  * case 语句中的值必须是字面量，不能是变量。

  * case 语句中的值必须和switch后面的值是同一类型，或者能够相互转换。 

  * case可以合并。

    ```java
    switch(month){
    		case 3: case 4: case 5:
    			System.out.println("春季!");
            	break;
            case 6: case 7: case 8:
                System.out.println("夏季!");
            	break;
            ...
    ```

  * 在每个 case 分支中要加上 break 语句，以避免case穿透现象。 

    ```java
    switch(month){
                case 3: case 4: case 5:
                    System.out.println("春季!");
            
                case 6: case 7: case 8:
                    System.out.println("夏季!");
            
                case 9: case 10: case 11:
                    System.out.println("秋季!");
                    break;
            
                case 12: case 1: case 2:
                    System.out.println("冬季!");
                    break;
            
                default:
                    System.out.println("您输入的月份不存在！");
            }
    //当month = 3时,会打印输出：春季！ 夏季！ 秋季！ 然后遇到break才结束，发生case穿透现象
    ```

  * 在 switch 语句中，一般都应该有一个 default 分支，用于处理一些特殊情况，以避免程序出错。  （当然，default语句不写，也不会编译报错。）

  * switch 语句中的 default 分支可以放在 switch 块的任意位置，但是通常建议将 default 分支放在所有 case 分支的最后面。（可读性好）

### 循环语句

#### for循环

```java
for(循环变量初始化;循环条件;循环变量迭代){  
    循环操作语句;  
}
```

* 循环条件是返回一个布尔值的表达式
* 括号内的初始化和变量迭代可以写到其他地方，但是两边的分号不能省略
* 可以有多条初始化语句，但要求类型一样，并且中间由逗号隔开；也可以有多条变量迭代语句，中间也用逗号隔开
* ![image-20240718104615370](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407181046689.png)

#### while循环

```java
循环变量初始化;
while(布尔表达式){
    循环体;
    循环变量迭代;   
}
```

* 先判断，再执行
* 执行原理：只要布尔表达式为true就会一直循环，直到布尔表达式结果为false，循环结束
* for循环适用于循环次数固定的。while循环适用于循环次数不固定的

#### do...while循环

```java
循环变量初始化;
do{   
    循环体语句;
    循环变量迭代;    
}while(循环条件);
```

* 先执行，再判断。至少执行一次
* 执行原理：先执行一次循环体，再判断布尔表达式，为true继续循环，直到布尔表达式结果为false，循环结束。

### 跳转语句  

#### break

```java
{
    ...
	break;
    ...
}
```

* 出现在switch语句用来终止switch语句的执行。

* 出现在循环[ for , while , do-while ]中，用来终止循环的执行。

* 默认情况下，单独使用“break;”语句，终止的是离它最近的循环。

* break 循环标记; 用来终止指定的循环。

  ```java
  f1:for(int j = 0; j < 2; j++){
      f2:for(int i = 1; i <= 10; i++){
          if(i == 5){
              break f1;
          }
          System.out.println("i = " + i);
      }
  }
  /**
   * 输出：
   * 		i = 1
   * 		i = 2
   * 		i = 3
   * 		i = 4
   */
  ```

#### continue

```java
{
    ...
	continue;
    ...
}
```

* continue; 终止当前本次循环，直接进入离它最近的循环继续。

* continue 循环标记; 终止当前本次循环，直接进入指定的循环继续。

  ```java
  f1:for(int j = 0; j < 2; j++){
      f2:for(int i = 1; i < 10; i++){
          if(i == 5){
              continue f1;
          }
          System.out.println("i = " + i);
      }
  }
  /**
   * 输出：
   * 		i = 1
   * 		i = 2
   * 		i = 3
   * 		i = 4
   * 		i = 1
   * 		i = 2
   * 		i = 3
   * 		i = 4
   */
  ```

  

#### return

* break; 终止循环。
* return; 终止方法。

## package

package包机制：

* 包机制作用：便于代码管理。

* 怎么定义包：在java源码第一行编写 package 语句。注意：package语句只能出现在java代码第一行。

* 包名命名规范中要求是全部小写。

* 包名命名规范：公司域名倒序 + 项目名 + 模块名 + 功能名。例如：

  com.powernode.oa.empgt.service

* 如果带包编译：javac -d 编译后的存放目录 java源文件路径

* 有了包机制后，完整类名是包含包名的，例如类名是：com.powernode.javase.chapter02.PackageTest

## import

* import语句用来引入其他类。

* A类中使用B类，A类和B类不在同一个包下时，就需要在A类中使用import引入B类。

* java.lang包下的不需要手动引入。

* import语句只能出现在package语句之下，class定义之前。

* import语句可以编写多个。

* import语句可以模糊导入：java.util.*;*

* import支持静态导入

  ```java
  import static java.lang.System.*;//将System类的所有静态变量和静态方法全部导入
  out.println("hello") //等同System.out.println("hello");
  ```


## IntelliJ IDEA

### 常用快捷键

```java

Alt + /  		//自动补全代码
Alt + Enter 	//导入该行需要的类
Alt + Ins		//生成构造器

Ctrl + B		//定位方法


```

```
alt+insert（新建/新增任何东西）
退出任何窗口ESC
编写源码的窗口最大化ctrl+shift+F12
psvm生成main方法
快速生成输出语句sout
IDEA会自动保存，自动编译
打开Project窗口alt+1
查找某个类：敲两次shift，选择classes，输入类名
切换选项卡：alt + 左右方向键
自动生成变量.var
删除一行ctrl+y
复制一行ctrl+d
在一个类当中查找方法ctrl+F12
生成for循环：fori
自动生成if语句.if
单行注释：ctrl + /
多行注释：ctrl + shift + /
查看源码：按ctrl别松手，鼠标移动到对应的类名下方，出现下划线，点击过去，可以查看类源码。
多行编辑：按alt别松手，鼠标拖动多行，完成多行编辑。
怎么快速生成创建对象语句：类名.new.var
怎么快速生成if语句：布尔类型值.if
怎么快速生成setter和getter方法：alt + insert，然后选择setter and getter生成。
怎么快速生成构造方法：alt + insert，然后选择Constructor。
在IDEA当中如何自动纠错：将光标移动到错误的位置，按atl + enter。会有提示，根据提示进行纠错。
移动代码到上一行：alt + shift + 上/下方向
怎么快速重写方法？alt + insert，选择Override....
怎么快速重写方法？ctrl + o
快速向下转型，并同时生成变量名：变量名.castvar
快速查看方法的参数：ctrl + p
返回上一步：ctrl + alt + 左方向键。 下一步：ctrl + alt + 右方向键。
代码格式化：ctrl + alt + L。
查看继承结构：ctrl + H
自动代码包裹：ctrl + alt + t


```



# 数组

* 数组概述

  * 在Java中，数组是一种用于存储多个相同数据类型元素的容器

  * 数组是一种引用数据类型，隐式继承Object。因此数组也可以调用Object类中的方法

  * 数组对象存储在堆内存中

    ![image-20240709232028310](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407092320655.png)

* 数组分类

  * 根据维数进行分类：一维数组，二维数组，三维数组，多维数组
  * 根据数组中存储的元素类型分类：基本类型数组，引用类型数组
  * 根据数组初始化方式不同分类：静态数组，动态数组

* 数组存储元素的特点

  * 数组长度一旦确定不可变
  * 数组中元素数据类型一致，每个元素占用空间大小相同
  * 数组中每个元素在空间存储上，内存地址是连续的
  * 每个元素有索引，首元素索引0，以1递增
  * 以首元素的内存地址作为数组对象在堆内存中的地址
  * 所有数组对象都有length属性用来获取数组元素个数。末尾元素下标：length-1

* 数组优点

  根据下标查询某个元素的效率极高。数组中有100个元素和有100万个元素，查询效率相同。时间复杂度O(1)。也就是说在数组中根据下标查询某个元素时，不管数组的长短，耗费时间是固定不变的，

  原因：知道首元素内存地址，元素在空间存储上内存地址又是连续的，每个元素占用空间大小相同，只要知道下标，就可以通过数学表达式计算出来要查找元素的内存地址。直接通过内存地址定位元素

* 数组缺点
  * 随机增删元素的效率较低。因为随机增删元素时，为了保证数组中元素的内存地址连续，就需要涉及到后续元素的位移问题。时间复杂度O(n)。O(n)表示的是线性阶，随着问题规模n的不断增大，时间复杂度不断增大，算法的执行效率越低。（不过需要注意的是：**对数组末尾元素的增删效率是不受影响的**。）
  * 无法存储大量数据，因为很难在内存上找到非常大的一块连续的内存

## 一维数组

* 一维数组是线性结构。二维数组，三维数组，多维数组是非线性结构
* 静态初始化
  * 第一种方式：`int[] arr = new int[]{1, 2, 3};`
  * 第二种方式：`int[] arr = {1,2,3};`

* 动态初始化

  * 使用场景：当创建数组时，不知道数组中具体存储哪些元素，可以使用动态初始化

  * 语法格式：`int[] arr = new int[3];`

  * 动态初始化一维数组之后，数组长度确定，数组中存储的每个元素将采用默认值

  * 数组的默认初始化值

    ```xml
    数据类型            默认值
    ===============================
    byte                0
    short               0
    int                 0
    long                0L
    float               0.0F
    double              0.0
    boolean             false
    char                '\u0000'
    引用数据类型          null
    ```

* 遍历数组

  * 普通for循环遍历

  * 增强for循环（for-each）

    ```java
    int[] arr = {1, 2, 3};
    for(int num : arr){
        // num代表数组中的每个元素
        System.out.println(num);
    }
    ```

    for-each的优点：代码简洁，可读性强

    for-each的缺点：没有下标，某些业务可能需要下标

* 方法在调用时如何给方法传一个数组对象？

  ```java
  public class ArrayTest {
      public static void main(String[] args) {
          // 第一种方式（静态初始化）：创建好数组对象，然后传进去
          int[] nums = {1,2,3,4};
          display(nums);
  
          // 第二种方式（静态初始化）：直接传
          //display({1,2,3,4}); // 这是错误的。
          display(new int[]{1,2,3,4}); // 这是正确的。注意这个小细节。
  
          // 动态初始化方式。
          display(new int[3]);//输出0,0,0
      }
  
      public static void display(int[] arr) {
          for(int num : arr) {
              System.out.println(num);
          }
      }
  }
  ```

* 当一维数组中存储引用时的内存图

  ![fc91c671d182645a28dc11819175669](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407092341337.png)

## 二维数组

* 二维数组是一个特殊的一维数组，特殊在：这个一维数组中每个元素是一个一维数组

* 静态初始化

  * 第一种方式：`int[][] arr = new int[][]{{1, 2, 3},{4, 5, 6},{7, 8, 9}};`(等长)

    ​		               `int[][] arr = new int[][]{{1},{2,3},{4,5,6}};`(不等长)

  * 第二种方式：`int[][] arr = {{1, 2, 3},{4, 5, 6},{7, 8, 9}};`

* 动态初始化

  * 等长：`int[][] arr = new int[3][4];`

  * 不等长：`int[][] arr = new int[3][];`

* 二维数组中元素的访问
  * 第一个元素：`arr[0][0]`
  * 最后一个元素：`arr[arr.length-1][arr[arr.length-1].length-1]`

* 二维数组的遍历

  ```java
  public class ArrayTest {
      public static void main(String[] args) {
          // 动态初始化一个二维数组：等长
          int[][] arr = new int[3][4];
  
          // 遍历
          for (int i = 0; i < arr.length; i++) {
              //System.out.println(arr[i]);
              // arr[i] 是一个一维数组。
              // 循环遍历一维数组
              for (int j = 0; j < arr[i].length; j++) {
                  System.out.print(arr[i][j] + " ");
              }
              System.out.println();
          }
  
          // 动态初始化一个二维数组：不等长
          int[][] nums = new int[3][];
  
          nums[0] = new int[]{1};
          nums[1] = new int[]{2,3};
          nums[2] = new int[]{4，5，6};
  
          // 遍历
          for (int i = 0; i < nums.length; i++) {
              for (int j = 0; j < nums[i].length; j++) {
                  System.out.print(nums[i][j] + " ");
              }
              System.out.println();
          }
      }
  }
  ```

  ```
  0 0 0 0 
  0 0 0 0 
  0 0 0 0 
  1 
  2 3 
  4 5 6 
  ```

  

# 面向对象编程

## 面向对象概述

* 面向过程：**关注点在实现功能的步骤上**；面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候一个一个依次调用就可以了；对于简单的流程是适合使用面向过程的方式
* 面向对象：**关注点在实现功能需要哪些对象的参与**；面向对象就是分析出解决这个问题都需要哪些对象的参加，然后让对象与对象之间协作起来形成一个系统；面向对象开发方式耦合度低，扩展能力强，采用面向对象的思想更加容易处理复杂的问题



## 类与对象

* 类：
  * 现实世界中，事物与事物之间具有共同特征，将这些共同的状态和行为提取出来，形成了一个模板，称为类
  * 类实际上是人类大脑思考总结的一个模板，类是一个抽象的概念
  * 状态在程序中对应属性。属性通常用变量来表示
  * 行为在程序中对应方法。用方法来描述行为动作
  * 类 = 属性 + 方法
* 对象：
  * 实际存在的个体
  * 对象又称为实例，通过类这个模板可以实例化n个对象。（通过类可以创造多个对象）
  * 创建一个对象 == 实例化一个对象 == 把类实例化

### 对象内存布局

* new运算符会在JVM的堆内存中分配空间用来存储实例变量。new分配的空间就是Java对象。
* 在JVM中对象创建后会有对应的内存地址，将内存地址赋值给一个变量，这个变量被称为引用。
* Java中的GC主要针对的是JVM的堆内存。

![3db858e54206d10a96957454856bf33](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407191515415.png)

![8c49c6140057575b569631b0391656d](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031628906.png)

![c6b4d29d52179a2e2bc122e40c37a94](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031628928.png)

![c0e70492adfb213d4242cb4728c03ed](javanote01.assets/c0e70492adfb213d4242cb4728c03ed.png)

![ac20158121ba6876820630e9c339940](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031628264.png)

多个对象在堆内存中，都有不同的内存划分，成员变量存储在各自的内存区域中，成员方法多个对象共用的一份

### 属性概念

* 叫法上 ：属性 == 成员变量 == feild(字段) ，成员变量是用来表示属性的。
* 属性是类的一个组成部分，一般是基本数据类型，也可以是引用类型。
* 属性的定义语法同变量 ，示例： 访问修饰符 属性类型  属性名；
* 属性如果不赋值，有默认值，规则和数组一致。

### 成员变量和局部变量

 **成员变量和局部变量的区别：**

* 类中位置不同：成员变量（类中方法外）局部变量（方法内部或方法声明上）
* 内存中位置不同：成员变量（堆内存）局部变量（栈内存）
* 生命周期不同：成员变量（随着对象的存在而存在，随着对象的消失而消失）局部变量（随着方法的调用而存在，醉着方法的调用完毕而消失）
* 初始化值不同：成员变量（有默认初始化值）局部变量（没有默认初始化值，必须先定义，赋值才能使用）

### 类和对象的内存分配机制

![adda3e7f97927b3ae60dcef5044c2a8](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031629096.png)

* 栈：一般存放基本数据类型（局部变量）
* 堆：存放对象（Cat cat ，数组等）
* 方法区：常量池（常量，比如字符串），类加载信息（每个类只会加载一次）

## 成员方法

#### 方法快速入门

```java
public class method {
    public static void main(String[] args) {
        Tools t1 = new Tools();			            //控制台输出：
        t1.speak();                                 //你好                                           
        t1.cal01(10);	 						    //calo1计算结果 = 55
        int result = t1.getSum(10, 20);    
        System.out.println("result = "+ result);    //result = 30
    }
}
class Tools {

    public void speak(){
        System.out.println("你好");
    }
    public void cal01 (int n){
        int res = 0;
        for (int i = 1; i <= n ; i++) {
            res += i;
        }
        System.out.println("cal01计算结果 = " + res);
    }
    public int getSum(int num1, int num2){
        int res = num1 + num2;
        return res;
    }

}
```

#### 方法调用机制

![96db0d047d696589fa33f6db510a47e](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031629072.png)

![image-20240718113211119](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407181132237.png)

* 方法只定义不调用是不会分配内存的。只是方法的字节码指令存储在元空间（方法区）中。
* 方法调用时会给该方法在JVM的栈内存中分配空间，此时发生压栈动作。这个方法的空间被称为栈帧。
* 栈帧中主要包括：局部变量表，操作数栈等。
* 当方法执行完毕，或者执行到return语句时，就会返回到调用的地方，同时该栈帧弹栈，方法内存空间释放
* 返回后继续执行后面的代码
* 当main方法（栈）执行完毕，整个程序退出，同时main栈空间也释放

#### 成员方法的定义

```java
[访问修饰符]  返回数据类型  方法名（形参列表）{
    语句;
    return 返回值;
}
```

* 返回数据类型：用来指定方法返回值的数据类型（方法执行结束后的结果类型）。只要是Java合法的数据类型，都可以，如果方法执行结束时没有返回任何数据，返回值类型也不能空着，需要写void关键字。
* 形参列表：简称形参。用来接收数据。参数个数0~N个。如果有多个，使用逗号隔开。每一个形式参数都可以看做局部变量。

#### 方法使用细节

* 一个方法**最多有一个**返回值（返回多个结果可以采用数组）

* 返回数据类型可以是任意类型，包含基本类型或引用类型（数组，对象）

* 如果方法要求有返回数据类型，则方法中最后执行语句必须为**return  值** ，而且要求返回值类型必须和return 的值类型一致或兼容

* 如果方法是 void ，则方法体中**可以没有**return 语句，或者只写 return，**不能带值**否则报错形参列表：

* 一个方法可以有零个参数，也可以有多个参数，中间用逗号隔开

* 参数类型可以为任意类型，包含基本类型或引用类型

* 调用带参数的方法时，一定对应着参数列表传入相同或兼容类型的参数

* 方法不能嵌套定义！

* 调用方法：如果方法执行结束后有返回值，可以采用变量接收该返回值。当然，也可以选择不接收

* 同一个类中的方法调用：直接调用

* 跨类中的方法调用：需要通过对象名调用

#### 方法传参机制

基本数据类型，传递的是值（值拷贝），形参的任何改变不影响实参

引用类型传递的是地址（传递的也是值，但是值是地址），可以通过形参影响实参

#### 方法的重载

* 方法重载概念

  方法重载指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载

  * 多个方法在同一个类中
  * 多个方法具有相同的方法名
  * 多个方法的参数不相同，类型不同或者数量不同

* 注意：

  * 重载仅对应方法的定义，与方法的调用无关，调用方式参照标准格式
  * 重载仅针对同一个类中方法的名称与参数进行识别，与返回值无关，换句话说不能通过返回值来判定两个方法是否相互构成重载

#### 可变参数

* 语法格式：`数据类型...`

  ```java
  public class DemoTest {
      public static void main(String[] args) {
          m1();
          m1(1);
          m1(1,2,3);  
      }
      //int... nums就是一个可变长度的参数
      public static void m1(int... nums){
          System.out.println("m1方法执行了");
      }
  }
  ```

  ```
  m1方法执行了
  m1方法执行了
  m1方法执行了
  ```

* 在形参列表中，可变长参数只能有一个，并且只能在参数列表的末尾出现

  ```java
  public static void m2(int... nums, int a){}//错误
  public static void m3(int... nums, int... nums2){}//错误
  ```

* 可变长度参数可以当做数组来看待

  ```java
  public class DemoTest {
      public static void main(String[] args) {
          m4(new int[]{1,2,3});
          //m4({1,2,3});//写法错误
          m5(new int[]{4,5,6});
          
      }
      public static void m4(int... nums){
          for (int num : nums) {
              System.out.print(num);//123
          }
      }
      public static void m5(int... nums){
          for (int i = 0; i < nums.length; i++) {
              System.out.print(nums[i]);//456
          }
      }
  }
  ```

  

## 构造器

* 基本介绍

​        构造器又叫构造方法，是类的一种特殊方法，主要作用是完成对新对象的初始化。

* 基本语法

  ```
  [访问修饰符] 方法名（形参列表）{}
  ```
  
* 基本案例

  ```java
  public class Constructor {
      public static void main(String[] args) {
          Person p1 = new Person("xiaoming",10);
          System.out.println(p1.age); 
          System.out.println(p1.name);
      }
  }
  class Person {
      String name;
      int age;
      public Person(String pname, int page){
          System.out.println("构造器被调用");
          name = pname;
          age = page;
      }
  }
  ```
  
  ```Java
  构造器被调用
  10
  xiaoming
  ```
  
* 构造器的作用

  * 构造方法的执行分为两个阶段：对象的创建和对象的初始化。这两个阶段不能颠倒，也不可分割
  * 在Java中，当我们使用关键字new时，就会在堆内存中开辟空间，然后给属性赋默认值，完成对象的创建（这个过程是在构造方法体执行前就完成了），这时虽然对象已经被创建出来了，但还没有被初始化。而初始化则是在执行构造方法体时进行的。构造方法体执行结束，表示对象初始化完毕
  
* 使用细节

  ①一个类可以定义多个不同的构造器，即构造器重载

  ②构造器名（方法名）和类名必须相同

  ③构造器不需要提供返回值，也不能写void，如果提供了返回值就是不构造方法了，而是普通方法

  ④构造方法执行结束后，会自动将创建的对象的内存地址返回，但方法体中不需要提供"return  值"这样的语句

  ⑤在创建对象时，系统会自动的调用该类的构造器完成对象的初始化
  
  ⑥如果一个类没有显示的定义任何构造方法，系统会默认提供一个无参数构造方法，也被称为缺省构造器。一旦显示      	的定义了构造方法，则缺省构造器将不存在
  
  

## this

* this是一个关键字
* this出现在实例方法中，代表当前对象。语法是：`this.`
* this本质上是一个引用，该引用保存当前对象的内存地址
* 通过`this.`可以访问实例变量，可以调用实例方法。
* this可以区分局部变量和成员变量的重名问题
  * 方法的形参如果与成员变量同名，不带this修饰的变量指的是形参，而不是成员变量
  * 方法的形参没有与成员变量同名，不带this修饰的变量指的是成员变量
* `this.`大部分情况下可以省略，用于区分局部变量和实例变量时不能省略
* this不能出现在静态方法中
* this存储在**实例方法栈帧的局部变量表的0号槽位**上

![image-20240703112308614](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031123697.png)

* `this(实参)`语法：
  * 只能出现在构造方法的第一行
  * 通过当前构造方法去调用本类中其他的构造方法
  * 作用是：代码复用

## 访问修饰符

* private（私有的）无法访问：使用private关键字，就意味着被声明的成员或方法，除了本类，其他任何类都无法访问。

* public（公共的）接口访问权限：使用public关键字，就意味着被声明的成员或方法对所有类都是可以访问的。

* protected（受保护的）继承访问权限：使用protected关键字，就意味着被声明的成员或方法，在子类以及相同包内的其他类都是可以访问的。

* default（默认的）包访问权限：即不写任何关键字，就意味着只要包相同，包内所有类都可以访问，包外都不可以访问，无关子类与否。
  ![f2addb23c780eeea2c79c4cd24af044](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031629456.png)

* 注意事项：
  * 类中的属性和方法访问权限共有四种：private、缺省默认、protected 和 public
  * 类的访问权限只有两种：public 和 缺省
  * 访问修饰符不能修饰局部变量

## 封装

* 面向对象三大特征之一：封装

* 什么是封装？

  封装是一种将数据和方法加以包装，使之成为一个独立的实体，并且把它与外部对象隔离开来的机制。具体来说，封装是将一个对象的所有“状态（属性）”以及“行为（方法）”统一封装到一个类中，从而隐藏了对象内部的具体实现细节，向外界提供了有限的访问接口，以实现对对象的保护和隔离。

* 封装的好处

  封装通过限制外部对对象内部的直接访问和修改，保证了数据的安全性，并提高了代码的可维护性和可复用性。

* 封装的实现步骤：
  * 将属性私有化
  * 提供一个公共的setter方法，用于对属性判断并赋值。可以放在构造器内
  * 提供一个公共的getter方法，用于获取属性的值

​	

## 继承

* 面向对象三大特征之一：继承

* 继承的作用：
  * 基本作用：代码复用
  * 重要作用：有了继承，才有了方法覆盖和多态机制

* 语法：`[修饰符列表] class 类名 extends 父类名{}`
* 继承相关的术语：当B类继承A类时
  * A类称为：父类、超类、基类、superclass
  * B类称为：子类、派生类、subclass

* 细节
  * Java只支持单继承，一个类只能直接继承一个类
  * Java不支持多继承，但支持多重继承（多层继承）
  * 子类继承父类后，除**私有的不支持继承、构造方法不支持继承**。其它的全部会继承
  * 子类继承了所有的属性和方法，但是私有的属性和方法不能在子类直接访问，要通过父类提供公共的方法去访问
  * 一个类没有显示继承任何类时，默认继承java.lang.Object类
  * Object类是JDK类库的根类，Java中所有类都是Object类的子类
  * 子类必须调用父类的构造器，先完成父类的初始化
  * 当创建子类对象时，不管使用子类的哪个构造器，默认情况下总会去调用父类的无参构造器，如果父类无参构造器被覆盖，则必须在子类的构造器中用super去指定使用父类的哪个构造器完成对父类的初始化工作，否则编译不通过
  * `super()`必须放在子类构造器的第一行（`super()`只能在构造器中使用）
  * `super()`和`this()`都只能放在构造器的第一行，因此这两个方法不能在同一个构造器中共存
  * 父类构造器的调用不限于直接父类，将一直往上追溯直到Object类（顶级父类）

* 继承的本质分析：

![image-20240704115301317](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407041153690.png)

```java
public class ExtendsTheory {
    public static void main(String[] args) {
        Son son = new Son();

        //1.首先看子类是否有该属性
        //2.若子类有这个属性，并且可以访问，则返回信息
        //3.若子类没有这个属性，则查看父类有没有这个属性，若父类有该属性，并且可以访问，就返回信息；若父类也没有则继续向上查找直到 Object类，如果都没有，则报错
        //4.按以上规则查找到某层级有这个属性，但不能访问，则报错（即使更高级父类有公开的该属性）
        System.out.println(son.age);//40
        System.out.println(son.name);//报错

    }
}
class GrandaPa {
    String name = "爷爷";
    String hobby = "旅游";
}
class Father extends GrandaPa {
    String name = "爸爸";
    int age = 40;

}
class Son extends Father{
    private String name = "儿子";
}
```





## super

**基本语法：**

1. 访问父类的属性，但不能访问父类的private属性

   super.属性名

2. 访问父类的方法，但不能访问父类的private方法

   super.方法名(实参）

3. 访问父类的构造器，只能放在子类的构造器的第一句，且只能出现一句

   super(实参）

   

**super是什么？**

**this代表的是当前对象。super代表的是当前对象中的父类型特征**

```java
public class Test01 {
    public static void main(String[] args) {

        Teacher t = new Teacher("张三", 20, "zhangsan@123.com", "北京朝阳", 10000.0);
        t.display();
    }
}
class Person {

    String name;
    int age;
    String email;
    String address;

    public Person() {
    }
}
class Teacher extends Person{
  	//特有属性
    double sal;
    
    String name;

    public Teacher() {
    }
    
    public Teacher(String name, int age, String email, String address, double sal) {
             
        this.name = name; 
        this.age = age;
        this.email = email;
        this.address = address;
        
        this.sal = sal;
	}
    
    public void display() {
        
        System.out.println(super.name);//null
        System.out.println(this.name);//张三

    }
}
```

![9edf5b06313d2e2e896fb9108d9e53e](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407191703888.png)



**super细节：**

* super不能使用在静态上下文中。

* this可以直接打印输出，而super不行

* 主要作用：当子类与父类中的成员（属性和方法）有重名时，为了访问父类的成员，必须使用super.

  

**supe(..)**

* super(实参); 通过子类的构造方法调用父类的构造方法，目的是为了完成父类型特征的初始化

* 当一个构造方法第一行没有显示的调用“super(实参);”，也没有显示的调用“this(实参)”，系统会自动调用super()。因此一个类中的无参数构造方法建议显示的定义出来。

* super(实参); 这个语法只能出现在构造方法第一行，故不能与this()共存

* 在Java语言中只要new对象，Object的无参数构造方法一定会执行

* 关于访问 this.属性 与 super.属性：

  ```java
  /*
  访问规则：
  父特有属性：super.属性 = this.属性 = 子构造器初始化的
  子特有属性：super.属性->报错   this.属性 = 子构造器初始化的
  父有子有：super.属性 是父构造器初始化的   this.属性 = 子构造器初始化的
  */
  public class Test {
      public static void main(String[] args) {
          B b = new B(7,8,9);
          b.disPlay();
      }
  }
  class A{
      public int a = 1;
      public int ab = 3;
  
      public A(int a, int ab) {
          this.a = a;
          this.ab = ab;
      }
  
  
  }
  class B extends A{
      public int b = 2;
      public int ab = 4;
  
      public B(int a, int ab, int b) {
          super(5,6);
          this.a = a;
          this.ab = ab;
          this.b = b;
  
  
      }
      public void disPlay(){
          System.out.println(this.a);//7
          System.out.println(this.b);//9
          System.out.println(this.ab);//8
          System.out.println(super.a);//7
  //        System.out.println(super.b); 编译报错
          System.out.println(super.ab);//6
      }
  }
  //注意：执行顺序：默认初始化->显示初始化->构造器初始化
  //     规则中说的是父/子构造器初始化的，若构造器没有初始化动作的话：
  //	   不论有参无参构造，对某个属性没有初始化动作 则反看其显示初始化，若没有显示初始化，则再反看默认初始化
  ```

* 关于访问 this.方法 与 super.方法：

  ```java
  /*
  this.方法 （同直接方法名调用） 查找规则：
      1. 先找本类，如果有，则调用
      2. 如果本类没有，则找父类，如果有，并且可以调用，则调用
      3. 如果父类也没有，则继续向上查找，直到Object类
      4. 如果查找过程中，找到了，但是私有的不能访问，则报错
      5. 如果查找过程中，没有找到，则提示方法不存在，编译不通过
  super.方法 的查找规则是直接查找父类，没有再向上查找，即跳过本类，其他规则一样
  */
  
  public class Test {
      public static void main(String[] args) {
          B b = new B();
          b.disPlay();
      }
  }
  class A{
  
      public void methodA(){
          System.out.println("A特有方法执行了");
      }
      public void methodAB(){
          System.out.println("父类AB方法执行了");
      }
  
  }
  class B extends A{
  
      public void methodB(){
          System.out.println("B特有方法执行了");
      }
  
      @Override
      public void methodAB() {
          System.out.println("子类重写的AB方法执行了");
      }
  
      public void disPlay(){
  
          this.methodA();
          this.methodB();
          this.methodAB();
          super.methodA();
  //        super.methodB();编译错误
          super.methodAB();
      }
  }
  /*
  输出：
          A特有方法执行了
          B特有方法执行了
          子类重写的AB方法执行了
          A特有方法执行了
          父类AB方法执行了
  
  */
  ```
  
  

## 方法重写/覆盖(override)

* 什么情况下考虑使用方法覆盖？

  当从父类中继承过来的方法无法满足当前子类的业务需求时

* 发生方法覆盖的条件：
  * 具有继承关系的父子类之间
  * 具有相同的方法名（必须严格一样）
  * 具有相同的形参列表（必须严格一样）
  * 具有相同的返回值类型（**可以是父类方法返回值类型的子类**）

* 方法覆盖细节：

  * 当子类将父类方法覆盖后，将来子类对象调用方法的时候，一定会执行重写之后的方法

  * @Override注解标注的方法会在编译阶段检查该方法是否重写了父类的方法
  * 如果返回值类型是引用数据类型，那么重写方法的返回值类型可以是原类型的子类型
  * 访问权限不能变低，可以变高（public > protected > 默认 > private)
  * 不能抛出比父类更高级别的异常
  * 私有方法不能继承，所以不能覆盖
  * 构造方法不能继承，所以不能覆盖
  * static,final修饰的方法不能覆盖
  * 方法覆盖针对实例方法，和静态方法无关
  * 方法覆盖针对实例方法，和实例变量无关



**重载与重写的比较：**

![c0028360e36cf813918eb9a2b01a82a](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031629651.png)



## 多态（polymorphic）

* **什么是向上转型和向下转型？**

  * java允许具有继承关系的父子类型之间的类型转换

  * 向上转型：子类型的对象可以赋值给一个父类型的引用

    ```
    父类类型（不仅限于直接父类）	引用名	=	new	子类类型（）；
    Animal animal = new Cat();
    ```

    可以调用父类中的所有成员（需遵守访问权限）；不能调用子类中特有成员；最终运行效果看子类的具体实现

    

  * 向下转型：父类型的引用可以转换为子类型的引用。但是需要加强制类型转换符  

    ```java
    子类类型  引用名	=	（子类类型）父类引用；
    Cat cat = (Cat) animal;
    ```

    向下转型后，可以调用子类类型中所有的成员

    

  * 无论是向上转型还是向下转型，前提条件是：两种类型之间必须存在继承关系。这样编译器才能编译通过

* 什么是多态？

  * 本质：**父类型引用指向子类对象**，Animal a = new Cat(); a.move();
  * 前提：两个对象（类）存在继承关系
  * 程序分为编译阶段和运行阶段：
    * 编译阶段：编译器只知道a是Animal类型，因此去Animal类中找move()方法，找到之后，绑定成功，编译通过。这个过程通常被称为静态绑定。
    * 运行阶段：运行时和JVM堆内存中的真实Java对象有关，所以运行时会自动调用真实对象的move()方法。这个过程通常被称为动态绑定。

  * 多态指的是：多种形态，编译阶段一种形态，运行阶段另一种形态，因此叫做多态，面向对象三大特征之一

* 注意事项：

  * 向上转型时，不能调用子类中特有成员

    ```java
    public class Fu {}
    
    public class Zi extends Fu {
        public String s = "子类特有属性";
        
        public void fun(){
            System.out.println("子类特有方法");
        }
    }
    ```

    ```java
    Fu f = new Zi();
    f.fun();//编译报错
    System.out.println(f.s);//编译报错
    ```

    ```xml
    原因：编译器只知道f是Fu类型，去Fu类中找fun()方法和s属性，结果没有找到，无法完成静态绑定，编译报错。
    ```

    如果就要f去调用fun( )方法，怎么办？

    ——向下转型

    什么时候我们会考虑使用向下转型？

    ——当需要调用的方法是子类中特有的方法时

    ```java
    Fu f = new Zi();
    Zi z = (Zi) f;
    z.fun();
    System.out.println(z.s);
    ```

    ```
    子类特有方法
    子类特有属性
    ```

  * 向下转型注意事项
    
    ```java
    public class TestDuoTai {
        public static void main(String[] args) {
            Animal animal = new Cat();
            Dog dog = (Dog) animal;
            dog.move();//编译可以通过，但出现运行时异常：java.lang.ClassCastException
            //在向下转型时，一般建议使用instanceof运算符进行判断来避免ClassCastException的发生
        }
    }
    class Animal{
        public void move(){
            System.out.println("动物在叫");
        }
    }
    class Cat extends Animal{
        @Override
        public void move() {
            System.out.println("猫:喵喵喵");
        }
    }
    class Dog extends Animal{
        @Override
        public void move() {
            System.out.println("狗:汪汪汪");
        }
    }
    ```
  

**instanceof运算符的使用**

* 语法格式

  ```java
  引用 instanceof 类
  ```

* 作用：判断 左边引用指向的对象类型 是否和 右边类的类型一样，或者是右边类的子类类型，是则返回ture,否则false

  接续上面示例代码：

  ```java
  Animal animal = new Cat();
  animal instanceof Cat // ture; animal指向的对象是Cat类型
  animal instanceof Animal //ture; animal指向的对象是Cat类型，是Animal的子类类型
  animal instanceof Dog // false; animal指向的对象是Cat类型不是Dog，且Cat也不是Dog的子类
  ```

* 注意事项：

  instanceof 前面的引用编译时的类型要么与后面的类型相同，要么与后面的类型具有父子继承关系

  ```java
  Animal animal = new Cat();
  animal instanceof Person //编译错误 animal编译类型是Animal,与Person类不具有父子继承关系
  ```



**多态的运行特点**

调用成员变量时：编译看左边，运行看左边

调用成员方法时：编译看左边，运行看右边

代码示例：

```java
Fu f = new Zi()；
    
//编译看左边的父类中有没有name这个属性，没有就报错
//在实际运行的时候，把父类name属性的值打印出来
System.out.println(f.name);

//编译看左边的父类中有没有show这个方法，没有就报错
//在实际运行的时候，运行的是子类中的show方法
f.show();
```

​	

属性没有重写之说！属性的值看编译类型

```java
public class PolyDetail {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.n);//10
        B b = new B();
        System.out.println(b.n);//20
    }
}
class A {
    int n = 10;
}
class B extends A {
    int n = 20;
}
```



**Java的动态绑定机制**

1.当调用对象方法时，该方法会和该对象的内存地址/运行类型绑定

2.当调用对象属性时，没有动态绑定机制，哪里声明哪里使用

```java
public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();
        System.out.println(a.sum());//40
        System.out.println(a.sum1());//30
    }
}
class A {
    public int i = 10;
    public int sum(){
        return  geti() + 10;
    }
    public int sum1(){
        return i + 10;
    }
    public int geti(){
        return i;
    }
}
class B extends A {
    public int i = 20;
    public int sum(){
        return i + 20;
    }
    public int sum1(){
        return i + 10;
    }
    public int geti(){
        return i;
    }
}
```

```java
public class DynamicBinding {
    public static void main(String[] args) {
        A a = new B();
        //a 的编译类型 A ，运行类型 B
        System.out.println(a.sum());//30
        System.out.println(a.sum1());//30
    }
}
class A {
    public int i = 10;
    public int sum(){
        return  geti() + 10;
    }
    public int sum1(){
        return i + 10;
    }
    public int geti(){
        return i;
    }
}
class B extends A {
    public int i = 20;

    public int sum1(){
        return i + 10;
    }
    public int geti(){
        return i;
    }
}
```

**多态的应用**：

1）多态数组

```java
public class PolyArr {
    public static void main(String[] args) {
        Person[] persons = new Person[5];
        persons[0] = new Person("jack", 20);
        persons[1] = new Student("jack", 20, 100);
        persons[2] = new Student("smith", 19, 80);
        persons[3] = new Teacher("travis", 30, 20000);
        persons[4] = new Teacher("scott", 40, 25000);

        for (int i = 0; i < persons.length; i++) {
            //persons[i]编译类型是 Person， 运行类型随实际情况而改变
            System.out.println(persons[i].say());
            if (persons[i] instanceof Student) {
                Student student = (Student) persons[i];
                student.study();
                //((Student) persons[i]).study();
            }else if (persons[i] instanceof Teacher){
                Teacher teacher = (Teacher) persons[i];
                teacher.teach();
                //((Teacher) persons[i]).teach();
            }else {
                System.out.println("error");
            }

        }
    }

}
class Person{
    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String say(){
        return "姓名："+ name +"\t" + "年龄："+age;
    }
}
class Student extends Person{
    private double score;

    public Student(String name, int age, double score) {
        super(name, age);
        this.score = score;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    @Override
    public String say() {
        return "学生"+ super.say() + "成绩：" + score;
    }
    public void study(){
        System.out.println("学生"+ getName()+ "正在上课");
    }
}
class Teacher extends Person{
    private double salary;

    public Teacher(String name, int age, double salary) {
        super(name, age);
        this.salary = salary;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    @Override
    public String say() {
        return "老师"+ super.say() + "薪水：" + salary;
    }
    public void teach(){
        System.out.println("老师"+ getName()+ "正在授课");
    }
}
```

```java
姓名：jack	年龄：20
error
学生姓名：jack	年龄：20成绩：100.0
学生jack正在上课
学生姓名：smith	年龄：19成绩：80.0
学生smith正在上课
老师姓名：travis	年龄：30薪水：20000.0
老师travis正在授课
老师姓名：scott	年龄：40薪水：25000.0
老师scott正在授课
```

2）多态参数

方法定义的形参类型为父类类型，实参类型允许为子类类型

## Object类详解

java.lang.Object是所有类的超类。java中所有类都实现了这个类中的方法。

### equals()方法

```java
public boolean equals(Object obj) {
    return (this == obj);
}
```

* == 和 equals的对比

  * ==  是比较运算符，既可以判断基本类型，也可以判断引用类型

    但只有一个比较规则，就是比较的是变量中保存的值是否相等

    引用类型变量中保存的值是对象的地址，即比较引用类型时，就是比较对象的地址

  * equals 是Object类中的方法，只能判断引用类型

    默认判断的是地址是否相等，子类中往往重写该方法，用于判断内容是否相等

* 注意：当需要重写equals()时，必须要彻底，当类中关联其他引用类型时，关联的类也要重写

### hashCode()方法

```java
public native int hashCode();
//这是一个本地方法，底层调用了C++写的动态链接库程序：xxx.dll
```

* hashCode：返回一个对象的哈希值，通常作为在哈希表中查找该对象的键值
* Object类的默认实现是根据对象的内存地址生成一个哈希码（即将对象的内存地址转换为整数作为哈希值）
*  hashCode()方法是为了HashMap、Hashtable、HashSet等集合类进行优化而设置的，以便更快地查找和存储对象
* 两个引用，如果指向的是同一个对象，则哈希值肯定是一样的
* 两个引用，如果指向不同对象，则哈希值是不一样的
* 哈希值主要根据地址号来的，但不能完全将哈希值等价于地址
* 在集合中，hashCode如果需要的话也会重写

### toString()方法

```java
public String toString() {
	return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```

* 这个方法的作用是：将java对象转换成字符串的表示形式

* 默认返回：全类名+@+哈希值的十六进制

* 通常重写toString方法，输出对象的属性（alt+insert -> toString）

* 当println()输出的是一个引用的时候，会自动调用“引用.toString()”，并且会避免空指针异常，

  而直接使用println(引用.toString())时如果为null会报空指针异常

### finalize()方法

```java
protected void finalize() throws Throwable { }
//从Java9开始，这个方法被标记已过时，不建议使用。作为了解。
```

* 当对象被回收时，系统（GC）自动调用该对象的finalize方法。子类可以重写该方法，做一些释放资源的操作
* 当某个对象没有任何引用时，则jvm就认为这个对象是一个垃圾对象，会使用垃圾回收机制来销毁该对象，在销毁对象前，会先调用finalize方法
* 垃圾回收机制的调用，是由系统来决定的（即有自己的GC算法），也可以通过System.gc()主动触发垃圾回收机制

### clone()方法

```java
/**
 * 关于Object类中的clone()方法：
 *
 * 1. clone方法作用：对象拷贝。通常在开发中需要保护原对象数据结构。通常复制一份，生成一个新对象，对新对象进行操作。
 *
 * 2. Object类中的默认实现：
 *      protected native Object clone() throws CloneNotSupportedException;
 *      受保护的方法，专门给子类使用的。
 *      本地方法。
 *      底层调用C++程序已经可以完成对象的创建了。
 *      我们现在要解决的问题是：怎么调用这个方法。
 *
 * 3. 怎么解决clone()方法的调用问题？
 *      在子类中重写该clone()方法。
 *      为了保证clone()方法在任何位置都可以调用，建议将其修饰符修改为：public
 *
 * 4. 凡是参加克隆的对象，必须实现一个标志接口：java.lang.Cloneable
 *      java中接口包括两大类：
 *          一类是：起到标志的作用，标志型接口。
 *          另一类是：普通接口。
 */
public class UserTest {
    public static void main(String[] args) throws CloneNotSupportedException {
        // 创建User对象
        User user = new User(20);


        // 克隆一个user对象
        // 报错原因：因为Object类中的clone()方法是protected修饰的。
        // protected修饰的只能在：本类，同包，子类中访问。
        // 但是以下这行代码不满足以上所说条件。
        // 这是一种浅克隆/浅拷贝。
        Object obj = user.clone();


        // 修改克隆之后的对象的age属性
        User copyUser = (User) obj;
        copyUser.setAge(100);
        System.out.println("克隆之后的新对象的年龄：" + copyUser.getAge());//100

        System.out.println("原始对象的年龄：" + user.getAge());//20

    }
}
class User implements Cloneable{
    private int age;

    public User() {
    }

    public User(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "User{" +
                "age=" + age +
                '}';
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

**浅克隆与深克隆**

两者区别：浅克隆不会克隆原对象中的引用类型，仅仅拷贝了引用类型的指向。深克隆则拷贝了所有。也就是说深克隆能够做到原对象和新对象之间完全没有影响。

浅克隆：

```java
public class Address {
    private String city;
    private String street;

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                ", street='" + street + '\'' +
                '}';
    }

    public Address() {
    }

    public Address(String city, String street) {
        this.city = city;
        this.street = street;
    }

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }
}
```

```java
public class User implements Cloneable{
    private String name;
    private Address addr;

    public User() {
    }

    public User(String name, Address addr) {
        this.name = name;
        this.addr = addr;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Address getAddr() {
        return addr;
    }

    public void setAddr(Address addr) {
        this.addr = addr;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", addr=" + addr +
                '}';
    }

    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

![f202ed0abb3e1e6419b73f3d13ffceb](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407222248022.png)

深克隆：

与浅克隆不同的是，深克隆不仅要克隆单个对象本身，该对象相关联的所有对象都克隆，如此修改克隆对象的属性时不会影响到原对象

具体实现：关联的类（Address）也要重写clone方法，User的clone方法也要改写法

```java
public class Address implements Cloneable{
    
	...
        
    @Override
    public Object clone() throws CloneNotSupportedException {
        return super.clone();
	}
	...
	
}
```

```java
public class User implements Cloneable{
    
	...
        
    @Override
    public Object clone() throws CloneNotSupportedException {
        // 重写方法，让其达到深克隆的效果。
        // User要克隆，User对象关联的Address对象也需要克隆一份。
        Address copyAddr = (Address)this.getAddr().clone();

        User copyUser = (User)super.clone();
        copyUser.setAddr(copyAddr);
        return copyUser;
    }
}
```



## static

static是一个关键字，翻译为：静态的。

static修饰的变量叫做静态变量,static修饰的方法叫做静态方法

所有static修饰的，访问的时候，直接采用“类名.”，不需要new对象

### 静态变量

* 静态变量/静态属性/类变量，是该类的所有对象共享的变量，任何一个该类的对象去访问它时，取到的值都相同，同样任何一个该类的对象去修改它时，修改的也是同一个变量。

* 使用场景：当所有对象的某个属性的值是相同的，建议将该属性定义为静态变量，来节省内存的开销

* 定义语法：

​		`访问修饰符  static  数据类型  变量名   ；`

​		`static  访问修饰符  数据类型  变量名   ；`

* 访问静态变量：

​    	类名 **.**  静态变量名

​		对象名 **.**  静态变量名

​		静态变量的访问修饰符的访问权限和普通属性一致

```java
public class Static_ {
    public static void main(String[] args) {
        
        System.out.println(A.name);
        A a = new A();
        System.out.println(a.name);
    }
}

class A {
    public static String name = "travis";
}
```

* 注意事项和细节
  * 加上 static 称为类变量或静态变量，否则称为实例变量/普通变量/非静态变量
  * 静态变量是该类的所有对象共享的，而实例变量是每个对象独享的
  * 实例变量不能通过 类名.类变量名 方式来访问
  * static 修饰的成员属于类，会存储在一块固定的内存区域（jdk8以后，这个区域在堆内存中），是随着类的加载而加载的，且只加载一次，所以只有一份，节省内存。所以，即使没有创建对象实例也可以访问，可以直接被类名调用。它优先于对象存在，所以，可以被所有对象共享。
  * 静态变量的生命周期是随着类的加载开始，随着类消亡而销毁
  * 使用“引用.”访问静态相关的（静态方法或者变量），即使引用为null，也不会出现空指针异常

### 静态方法

* 基本介绍：

  静态方法也叫类方法

  `访问修饰符 static 数据返回类型 方法名(){}`

  `static 访问修饰符 数据返回类型 方法名(){}`

* 静态方法的调用：

  类名.类方法

  对象名.类方法

  前提：满足访问修饰符的访问权限

* 使用场景：

  当我们希望不创建实例，也可以调用某个方法（即当做工具来使用），这时适合将方法设为静态方法，提高开发效率

* 注意事项和细节：

  * 静态方法和普通方法都是随着类的加载而加载，将结构信息存储在方法区

  * 静态方法中无this的参数

    实例方法中隐含着this参数

  * 实例方法和对象有关，需要通过对象名调用，不能通过类名调用

    静态方法既可以通过类名调用，也可以通过对象名调用

  * 静态方法中不允许使用和对象有关的关键字，比如this和super，因此无法直接访问实例变量和调用实例方法，只能访问 静态变量 或 静态方法

  * 实例方法既可以访问非静态变量（方法），也可以访问静态变量（方法），同时遵循访问权限

### 静态代码块

* 静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行。
* 静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中。



## main方法

```java
public static void main(String[] args){ }
```

* main方法是JVM调用，所以该方法的访问权限必须是public

* JVM在执行main方法时不必创建对象，所以必须加static

* JVM负责给main方法准备一个String[]一维数组的对象，String[] args作用是接收命令行参数用的

  ```
  执行命令：java ArrayTest abc def xyz
  底层JVM是怎么做的？
  命令行参数："abc def xyz"
  JVM会将以上字符串以“空格”进行拆分，生成一个新的数组对象。
  最后这个数组对象是：String[] args = {"abc","def","xyz"};
  如果命令在使用的时候，没有提供参数，则args是个长度为0的数组，并不是null
  ```

* 在main方法中，可以直接调用main方法所在类的静态方法或静态属性

  但不能直接访问该类中的非静态成员，必须创建该类的一个实例对象后，才能通过这个对象去访问类中的非静态成员




## 代码块

* 基本介绍：

  代码块又称为初始化块，属于类中的成员（即是类的一部分），类似于方法，将逻辑语句封装在方法体中，通过{ }包围起来，但和方法不同，没有方法名，没有参数，没有返回，只有方法体，而且不用通过对象或类显示调用，而是加载类时，或创建对象时隐式调用

* 基本语法：

  `[修饰符] {`

  ​	`代码`

  `};`

  说明：①修饰符可选，但要写的话只能写 static

  ​	    ②代码块分为两类，使用static修饰的叫静态代码块，没有static修饰的叫普通代码块/非静态代码块

  ​	    ③逻辑语句可以为任何逻辑语句（输入输出、方法调用、循环、判断...)

  ​	    ④ ；号可以写也可以不写

* 代码块的理解：
  * 相当于另外一种形式的构造器（对构造器的补充机制），可以做初始化的操作
  * 如果多个构造器中在最开始的时候都有重复的语句，可以抽取到初始化块中，提高代码的复用性（代码块执行早于构造方法）

* 注意事项和使用细节：

  * static代码块也叫静态代码块，作用是对类进行初始化，而且它随着类的加载而执行，并且**只会执行一次**（类只加载一次）。如果是普通代码块，每创建一个对象就会执行
  
  * 静态代码块在类加载时执行，一个类中可以编写多个静态代码块，遵循自上而下的顺序依次执行
  
  * 静态代码块代表了类加载时刻，如果你有代码需要在此时刻执行，可以将该代码放到静态代码块中
  
  * 类什么时候被加载？
    * 创建对象实例时（new）
    * 创建子类对象实例，父类也会被加载，而且父类先被加载
    * 使用类的静态成员时（静态属性，静态方法）
  
  * 静态代码块的执行和静态变量的初始化早于main方法的执行
  
  * 普通代码块在创建对象实例时会被隐式的调用，被创建一次就会调用一次；
  
    如果只是使用类的静态成员时，普通代码块并不会执行
  
  * 创建一个对象时，执行顺序：
  
    * 0.非静态变量默认初始化初始化
  
    * 1.调用静态代码块和静态属性初始化
  
      注：静态代码块和静态属性初始化调用的优先级一样，如果有多个静态代码块和多个静态变量初始化，则按定义顺序调用
  
    * 2.调用普通代码块和普通属性初始化
  
      注：普通代码块和普通属性初始化（显示初始化）调用的优先级一样，如果有多个普通代码块和多个普通变量初始化，则按定义顺序调用
  
    * 3.调用构造器
  
  * 构造器的最前面其实隐含了 super() 和调用普通代码块。super()必须在第一行，故先执行。静态相关的代码块，属性初始化，在类加载时就执行完毕
  
  * 静态代码块只能直接调用静态成员，普通代码块可以调用任意成员	 	
  

## final 

* 基本介绍：

  final 可以修饰 类、属性、方法和局部变量

* 注意事项和细节：

  * final修饰的类不能被继承，但是可以实例化对象
  * final修饰的方法不能被覆盖
  * 如果类不是final类，但是含有final方法，则该方法虽然不能重写，但是可以被继承
  * 一般来说，如果一个类已经是final类了，就没有必要再将方法修饰成final方法了
  * final不能修饰构造器
* final修饰的属性又叫常量，一般用XX_XX_XX来命名（如TAX_RATE)
  * final 修饰的属性在定义时，必须赋初值，并且以后不能再修改，赋值可以在如下位置之一：
    * 定义时，如 public final double TAX_RATE = 0.08 ;
    * 在构造器中
  * 在代码块中
  * 如果final 修饰的属性是静态的，则初始化的位置只能是
  * 定义时
    * 静态代码块中
* final修饰的引用，一旦指向某个对象后，不能再指向其它对象。但指向的对象内部的数据是可以修改的
  * final 和 static 往往搭配使用效率更高，不会导致类的加载，因为底层编译器做了优化处理
* 包装类（Integer,Double,Float,Boolean等）和String都是final类

##  抽象类

当一个类中存在抽象方法时，需要将该类声明为abstract类

所谓抽象方法就是没有实现的方法，即没有方法体包括“{ }”

```java
abstract class Animal{
    String name;
    public abstract void eat();
}
```

* 基本介绍：
  * 用abstract关键字来修饰一个类时，这个类就叫抽象类
  * 用abstract关键字来修饰一个方法时，这个方法就叫抽象方法

* 使用情况：

  如果类中有些方法无法实现或者没有意义，可以将方法定义为抽象方法。类定义为抽象类。这样在抽象类中只提供公共代码，具体的实现强行交给子类去做。比如一个Person类有一个问候的方法greet()，但是不同国家的人问候的方式不同，因此greet()方法具体实现应该交给子类。

* 注意事项和细节：
  * 抽象类有构造方法，但无法实例化。抽象类的构造方法是给子类使用的
  * 抽象类不一定要包含abstract方法
  * 一旦类包含了abstract方法，则这个类必须声明为abstract
  * abstract 只能修饰类和方法，不能修饰属性和其他的
  * 抽象类也是类，可以有任意成员
  * 如果一个类继承了抽象类，则它必须实现/重写抽象类的**所有**抽象方法，**除非它自己也声明为abstract类**
  * 抽象方法不能使用private、final和static来修饰，因为这些关键字都是和重写相违背

##  接口

* 快速入门：

  ```java
  public interface UsbInterface {
      public void start();
      public void stop();
  }
  
  ```

  ```java
  public class Phone implements UsbInterface {
      @Override
      public void start() {
          System.out.println("手机开始工作");
      }
  
      @Override
      public void stop() {
          System.out.println("手机停止工作");
      }
  }
  ```

  ```java
  public class Camera implements UsbInterface {
      @Override
      public void start() {
          System.out.println("相机开始工作");
      }
  
      @Override
      public void stop() {
          System.out.println("相机停止工作");
      }
  }
  ```

  ```java
  public class Computer {
      public void work(UsbInterface usbInterface){
          usbInterface.start();
          usbInterface.stop();
      }
  }
  ```

  ```java
  public class interface_ {
      public static void main(String[] args) {
          Camera camera = new Camera();
          Phone phone = new Phone();
          Computer computer = new Computer();
          computer.work(phone);
          System.out.println("================");
          computer.work(camera);
      }
  }
  ```

  ```java
  手机开始工作
  手机停止工作
  ================
  相机开始工作
  相机停止工作
  ```

* 基本介绍：

  接口（interface）在Java中表示一种规范或契约，它定义了一组抽象方法和常量，用来描述一些实现这个接口的类应该具有哪些行为和属性。接口和类一样，也是一种引用数据类型。


* 语法格式：

```java
interface 接口名{
    常量;
    方法;
}
```



注：在JDK7.0前，接口里所有的方法都没有方法体，即都是抽象方法；

 JDK8.0及以后的版本接口可以有静态方法和默认方法，且必须有方法的具体实现。

```java
default public void func(){
}
public static void func(){
}
```





* 注意事项和细节：
  * 抽象类是半抽象的，接口是完全抽象的。接口没有构造方法，也无法实例化
  
  * 接口中只能定义：常量+抽象方法。
  
  * 接口中的常量默认 public static final 修饰符，可以省略，接口中的抽象方法abstract也可以省略
  
  * 接口中所有的方法都是public方法，但不用写public
  
  * 类与接口是实现关系（implements），接口与接口是继承关系
  
  * 接口不能继承其他的类，但是可以继承多个别的接口
  
  * 一个类可以同时实现多个接口，语法是：`class 类 implements 接口A,接口B{}`
  
  * 一个非抽象的类实现接口必须将接口中所有的抽象方法全部实现
  
  * 抽象类实现接口，可以不用实现接口的方法
  
  * 接口中属性（常量）的访问形式：接口名.属性名
  
  * 接口的修饰符只能是 public 和默认，这点和类的修饰符是一样的 
  
  * Java8之后，接口中允许出现默认方法和静态方法(JDK8新特性)
  
    * 引入默认方式是为了解决接口演变问题：接口可以定义抽象方法，但是不能实现这些方法。所有实现接口的类都必须实现这些抽象方法。这会导致接口升级的问题：当我们向接口添加或删除一个抽象方法时，这会破坏该接口的所有实现，并且所有该接口的用户都必须修改其代码才能适应更改。这就是所谓的"接口演变"问题。
  
    * 引入的静态方法只能使用本接口名来访问，无法使用实现类的类名访问。
  
  * JDK9之后允许接口中定义私有的实例方法（为默认方法服务的）和私有的静态方法（为静态方法服务的）。
  
  * **所有的接口隐式的继承Object**。因此接口也可以调用Object类的相关方法
  
  

**接口与抽象类的异同**

抽象类和接口虽然在代码角度都能达到同样的效果，但适用场景不同：

①抽象类主要适用于公共代码的提取。当多个类中有共同的属性和方法时，为了达到代码的复用，建议为这几个类提取出来一个父类，在该父类中编写公共的代码。如果有一些方法无法在该类中实现，可以延迟到子类中实现。这样的类就应该使用抽象类。

②接口主要用于功能的扩展。例如有很多类，一些类需要这个方法，另外一些类不需要这个方法时，可以将该方法定义到接口中。需要这个方法的类就去实现这个接口，不需要这个方法的就可以不实现这个接口。接口主要规定的是行为。

更多异同点：https://blog.csdn.net/Aure219/article/details/124717184



## 内部类

* 基本介绍

  一个类的内部又完整的嵌套了另一个类结构，被嵌套的类称为内部类（inner class），嵌套其他类的类称为外部类（outer class）。是类的第五大成员（属性、方法、构造器、代码块、内部类），内部类的最大特点就是可以直接访问外部类的私有成员，并且可以体现类与类之间的包含关系

  

* 内部类的分类

  1. **实例内部类**，类定义在了成员位置 (类中方法外称为成员位置，无static修饰的内部类)
  
  2. **静态内部类**，类定义在了成员位置 (类中方法外称为成员位置，有static修饰的内部类)
  
  3. **局部内部类**，类定义在方法内
  4. **匿名内部类**，没有名字的内部类，可以在方法中，也可以在类中方法外



### **局部内部类**

* 定义在外部类的局部位置，和局部变量一个级别

* 局部内部类是定义在外部类的局部位置，通常在方法或代码块中
* 局部内部类不能添加访问修饰符，但是可以使用 final
* 作用域：仅仅在定义它的方法或代码块中
* 局部内部类能否访问外部类成员，取决于局部内部类所在的方法：
  * 若方法是静态的，则只能访问外部类的静态成员（包括私有）
  * 若方法是实例的，则可以访问所有成员（包括私有）

* 局部内部类在访问外部的局部变量时，这个局部变量必须是final修饰的，从JDK8开始，不需要手动添加final了，但JVM会自动添加

```java
public class LocalInnerClass {
    public static void main(String[] args) {
        Outer outer01 = new Outer();
        outer01.function();
        //Inner inner = new Inner();错误，外部其他类不能访问局部内部类，因为局部内部类地位是一个局部变量
    }
}

class Outer {
    private int n = 100;
    private void fun01() {
        System.out.println("fun01()执行中");
    }
    public void function() {
        //局部变量
        int i = 100;
        //局部内部类
        final class Inner {
            //本质仍然还是个类
            private int n = 200;
            public void fun02() {
              //如果外部类和局部内部类的成员重名时，默认遵守就近原则，如果想访问外部类的成员，则可以使用（外部类名.this.成员）去访问,这里Outer.this指的是调用function()的对象outer01，如果只用（this.同名成员），则this这里指的是调用fun02()的对象inner
                System.out.println("内部类的n = " + n + "  外部类的n = " + Outer.this.n);
                System.out.println("this.n = " + this.n);
                System.out.println("i = " + i);
                fun01();
            }
        }
        //class Inner01 extends Inner {}
        //5.外部类在方法中，创建Inner对象，然后调用方法即可
        Inner inner = new Inner();
        inner.fun02();
    }
}
```

```java
内部类的n = 200  外部类的n = 100
this.n = 200
i = 100
fun01()执行中
```



### **匿名内部类**

* 隐藏了名字的内部类，可以写在成员位置，也可以写在局部位置

* 语法格式

  ```java
  new 类名或接口名(){
  	重写方法;
  };
  ```

* 格式细节：包含了继承或实现，方法重写，创建对象。整体就是一个类的子类对象或者接口的实现类对象

* 使用场景：当方法的参数是接口或者类时，以接口为例，可以传递这个接口的实现类对象，如果实现类只需要使用一次，就可以用匿名内部类简化代码

  ```java
  public class Test {
      public static void main(String[] args) {
  
          Computer computer = new Computer();
  
          computer.conn(new Usb(){
              @Override
              public void read() {
                  System.out.println("read.....");
              }
  
              @Override
              public void write() {
                  System.out.println("write.....");
              }
          });
      }
  }
  
  class Computer {
      public void conn(Usb usb){
          usb.read();
          usb.write();
      }
  }
  
  interface Usb {
      void read();
      void write();
  }
  ```

  



### 实例内部类

定义在外部类的成员位置，并且没有static修饰

**内部类的使用格式**：

```java
 外部类.内部类。 // 访问内部类的类型都是用 外部类.内部类
```

**获取成员内部类对象的两种方式**：

方式一：外部直接创建成员内部类的对象

```java
外部类.内部类 变量 = new 外部类（）.new 内部类（）;
```

方式二：在外部类中定义一个方法提供内部类的对象



实例内部类的细节

1. 实例内部类可以被四个访问权限修饰符所修饰，比如： private，默认，protected，public
2. 在实例内部类里面，JDK16之前不能定义静态变量，JDK16开始才可以定义静态变量。
3. 创建内部类对象时，对象中有一个隐含的Outer.this记录外部类对象的地址值。（请参见3.6节的内存图）

详解：

​	内部类被private修饰，外界无法直接获取内部类的对象，只能通过3.3节中的方式二获取内部类的对象

​	被其他权限修饰符修饰的内部类一般用3.3节中的方式一直接获取内部类的对象

​	

​	内部类如果想要访问外部类的成员变量，外部类的变量必须用final修饰，JDK8以前必须手动写final，JDK8之后不需要手动写，JDK默认加上。

注意：内部类访问外部类对象的格式是：**外部类名.this**

```java
public class Test {
    public static void main(String[] args) {
        Outer.inner oi = new Outer().new inner();
        oi.method();
    }
}

class Outer {	// 外部类
    private int a = 30;

    // 在成员位置定义一个类
    class inner {
        private int a = 20;

        public void method() {
            int a = 10;
            System.out.println(???);	// 10   答案：a
            System.out.println(???);	// 20	答案：this.a
            System.out.println(???);	// 30	答案：Outer.this.a
        }
    }
}
```



### **静态内部类**

**静态内部类特点**：

* 静态内部类是一种特殊的成员内部类

- 有static修饰，属于外部类本身的
- 总结：静态内部类与其他类的用法完全一样。只是访问的时候需要加上外部类.内部类
- **拓展1**:静态内部类可以直接访问外部类的静态成员
- **拓展2**:静态内部类不可以直接访问外部类的非静态成员，如果要访问需要创建外部类的对象
- **拓展3**:对于静态内部类，四个访问修饰符都可以用
- **拓展4**:静态内部类中没有隐含的Outer.this

**内部类的使用格式**：

```
外部类.内部类。
```

**静态内部类对象的创建格式**：

```java
外部类.内部类  变量 = new  外部类.内部类构造器;
```

**调用方法的格式：**

* 调用非静态方法的格式：先创建对象，用对象调用
* 调用静态方法的格式：外部类名.内部类名.方法名();

**案例演示**：

```java
// 外部类：Outer01
class Outer01{
    private static  String sc_name = "黑马程序";
    // 内部类: Inner01
    public static class Inner01{
        // 这里面的东西与类是完全一样的。
        private String name;
        public Inner01(String name) {
            this.name = name;
        }
        public void showName(){
            System.out.println(this.name);
            // 静态内部类可以直接访问外部类的静态成员。
            System.out.println(sc_name);
        }
    }
}

public class InnerClassDemo01 {
    public static void main(String[] args) {
        // 创建静态内部类对象。
        // 外部类.内部类  变量 = new  外部类.内部类构造器;
        Outer01.Inner01 in  = new Outer01.Inner01("张三");
        in.showName();
    }
}
```





# 枚举

枚举类型在Java中是一种引用数据类型。

合理使用枚举类型可以让代码更加清晰、可读性更高，可以有效地避免一些常见的错误。

什么情况下考虑使用枚举类型？

* 这个数据是有限的，并且可以一枚一枚列举出来的。
* 枚举类型是类型安全的，它可以有效地防止使用错误的类型进行赋值。

枚举如何定义？以下是最基本的格式：

```java
enum 枚举类型名 {
枚举值1, 枚举值2, 枚举值3, 枚举值4}
```

通过反编译(javap)可以看到：

* 所有枚举类型默认继承java.lang.Enum,因此枚举类型无法继承其他类。

* 所有的枚举类型都被final修饰，所以枚举类型是无法继承的

* 所有的枚举值都是常量

* 所有的枚举类型中都有一个values数组（可以通过values()获取所有枚举值并遍历）

  ```java
  enum Color {
      BLUE, GREEN, RED
  }
  
  public class EnumTest {
      public static void main(String[] args) {
  
          // 获取所有的枚举值，遍历
          Color[] colors = Color.values();
  
          for(Color color : colors){
              System.out.println(color);//BLUE
                                        //GREEN
                                        //RED
          }
      }
  }
  ```

**枚举的高级用法**

* 普通类中可以编写的元素，枚举类型中也可以编写:
  * 静态代码块，构造代码块
  * 实例方法，静态方法
  * 实例变量，静态变量

* 枚举类中的构造方法是私有化的（默认就是私有化的，只能在本类中调用）
  * 构造方法调用时不能用new,直接使用“枚举值(实参);”调用
  * 每一个枚举值相当于枚举类型的实例

* 枚举类型中如果编写了其他代码，必须要有枚举值，且枚举值的定义要放到最上面，最后一个枚举值的分号不能省略
* 枚举类因为默认继承了java.lang.Enum，因此不能再继承其他类，但可以实现接口
  * 第一种实现方式：在枚举类中实现
  * 第二种实现方式：让每一个枚举值实现接口

```java
public interface Eatable {
    void eat();
}
```

```java
public enum Season implements Eatable{

    // 定义了有参数的构造方法之后
    // 通过以下代码来调用构造方法
    // 注意枚举类的构造方法不能使用new来调用
    // 并且枚举类的构造方法只能在本类中调用
    SPRING("春季", "春意盎然"){
        @Override
        public void eat(){
            System.out.println("春季吃苹果");
        }
    },
    SUMMER("夏季", "天太闷热"){
        @Override
        public void eat(){
            System.out.println("夏季吃西瓜");
        }
    },
    AUTUMN("秋季", "秋高气爽"){
        @Override
        public void eat(){
            System.out.println("秋季吃苹果");
        }
    },
    WINTER("冬季", "白雪皑皑"){
        @Override
        public void eat(){
            System.out.println("冬季吃苹果");
        }
    };
 /*
实际上枚举值可以看作如下定义：
public final static Season SPRING = new Season("春天", "春意盎然"); 
只不过简化为SPRING("春天", "春意盎然")
如果使用无参构造器创建枚举对象，则实参列表和小括号都可以省略
*/

    // 提供属性
    private final String name;
    private final String desc;

    public String getName() {
        return name;
    }

    public String getDesc() {
        return desc;
    }

    // 对于枚举类型来说，里面可以定义什么呢？普通类中可以定义的，枚举类型也可以。
    // 静态代码块 构造代码块
    // 静态方法，实例方法
    // 静态变量，实例变量

    /*// 静态代码块
    static {
        System.out.println("枚举类型Season的静态代码块执行了");
    }

    // 构造代码块
    {
        System.out.println("构造代码块执行了");
    }

    // 静态变量
    public final static int A = 10;
    // 实例变量
    private final int b = 20;
    // 静态方法
    public static int getA(){
        return A;
    }
    // 实例方法
    public int getB(){
        return b;
    }*/

    // 枚举类型也可以定义构造方法
    // 构造方法是私有的。
    Season(String name, String desc) {
        this.name = name;
        this.desc = desc;
    }

    /*@Override
    public void eat(){
        System.out.println("吃啥都行！");
    }*/
}
```

```java
public class SeasonTest {
    public static void main(String[] args) {
        Season season = get();
        switch (season) {
            case SPRING -> System.out.println(Season.SPRING.getDesc());
           case SUMMER -> System.out.println(Season.SUMMER.getDesc());//此处执行，输出：天太闷热
            case AUTUMN -> System.out.println(Season.AUTUMN.getDesc());
            case WINTER -> System.out.println(Season.WINTER.getDesc());
        }

        // 遍历
        Season[] seasons = Season.values();
        for(Season s : seasons){
            System.out.println(s.getName() + "-->" + s.getDesc());
            s.eat();
        }
    }

    public static Season get(){
        return Season.SUMMER;
    }
}
```



**自定义类实现枚举**

* 构造器私有化
* 类内部创建一组对象
* 对外暴露对象（通过为对象添加public final static修饰）
* 可以提供 get 方法，但是不要提供 set 方法

```java
public class Enum_ {
    public static void main(String[] args) {
        System.out.println(Season.AUTUMN);

    }
}

class Season {

    private String name;
    private String desc;
    public final static Season SPRING = new Season("春天", "温暖");
    public final static Season SUMMER = new Season("夏天", "炎热");
    public final static Season AUTUMN = new Season("秋天", "凉爽");
    public final static Season WINTER = new Season("冬天", "寒冷");
    private Season(String name, String desc) {
        this.name = name;
        this.desc = desc;

    }

    public String getName() {
        return name;
    }

//    public void setName(String name) {
//        this.name = name;
//    }

    public String getDesc() {
        return desc;
    }

    @Override
    public String toString() {
        return "Season{" +
                "name='" + name + '\'' +
                ", desc='" + desc + '\'' +
                '}';
    }
//    public void setDesc(String desc) {
//        this.desc = desc;
//    }
}
```



**enum常用方法**



<img src="https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031630639.png" alt="4df721006371caf9c178e0b5b827fb5" style="zoom:150%;" />



# 注解

注解（Annotation）也被称为元数据（Metadata），用于修饰解释包、类、方法、属性、构造器、局部变量等数据信息

修饰注解的注解，称为元注解

和注释一样，注解不影响程序逻辑，但注解可以被编译或运行，相当于嵌入在代码中的补充信息

使用Annotation时要在其前面增加@符号，并把Annotation当成一个修饰符使用，用于修饰它支持的程序元素

三个基本的Annotation：

* @Override：限定某个方法，是重写父类方法，该注解只能修饰方法
* @Deprecated：用于表示某个程序元素已过时
* @SupperessWarnings：抑制编译器警告

# 异常（Exception）

## 1. 异常概述

* 基本概念

  Java语言中，将程序执行中发生的不正常情况称为“异常”（开发过程中的语法错误和逻辑错误不是异常）

* 执行过程中所发生的异常事件可分为两大类
  * Error（错误）：Java虚拟机无法解决的严重问题。如：JVM系统内部错误、资源耗尽等严重情况，如栈溢出和内存不足。程序出现错误，只有一个结果，就是终止JVM的执行，所有的错误都是无法处理的，但是是可抛出的
  
  * Exception：其他因编程错误或偶然的外在因素导致的一般性问题，可以使用针对性的代码进行处理。如空指针访问，试图读取不存在的文件，网络连接中断等。所有的异常都是可抛出的，同时也都是可处理的。
  
    Exception 分为两大类：运行时异常 和 编译时异常(除了运行时异常之外的)

* 在java中，异常是以类和对象的形式存在的，定义异常本质就是定义一个类，异常如果发生的话，也需要通过这个类new对象。如在某行代码发生空指针异常的时候，底层一定new了一个NullPointerException对象

## 2. 异常继承体系结构

![dc7ace23033dcafbd64c6ae2de5425b](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031630261.png)

* 异常体系中最上层父类：Exception

* 运行时异常 和 编译时异常的区别

  * 运行时异常：

    *  RuntimeException本身及其所有子类，都是运行时异常
    *  在编译阶段可以选择处理，也可以不处理，没有硬性要求
    * 运行时异常一般是由程序员的错误引起的，并且不需要强制进行异常处理

  * 编译时异常：

    * Exception所有的子类（除RuntimeException之外），都是编译时异常
    
    * 在编译阶段必须提前处理，如果不处理编译器报错
    
    * 编译时异常一般是由外部环境或外在条件引起的，如网络故障、磁盘空间不足、文件找不到等
    
      
  
  注意：编译时异常并不是在编译阶段发生的异常，所有的异常发生都是在运行阶段的，因为每个异常发生都是会new异常对象的，new异常对象只能在运行阶段完成。那为什么叫做编译时异常呢？这是因为这种异常必须在编译阶段提前预处理，如果不处理编译器报错，因此而得名编译时异常

* 异常的发生

  ```Java
  public static void main(String[] args) {
      //异常的发生需要经过两个阶段
      //1.创建异常对象
      NullPointerException e = new NullPointerException();
      //2.让异常发生（手动抛出异常）
      throw e;
  }
  ```

  不过通常简写为：

  ```Java 
  throw new NullPointerException();
  ```

## 3. 自定义异常

①第一步：编写异常类继承 Exception（编译时异常） 或 RuntimeException（运行时异常）

②第二步：提供一个无参数构造方法，再提供一个带`String msg`参数的构造方法，在构造方法中调用父类的构造方法

```java
/**
 * 定义一个编译时异常
 */
public class IllegalAgeException extends Exception {
    public IllegalAgeException() {
    }

    public IllegalAgeException(String message) {
        super(message);
    }
}
```

```java 
/**
 * 定义一个运行时异常
 */
public class IllegalNameException extends RuntimeException {
    public IllegalAgeException() {
    }

    public IllegalAgeException(String message) {
        super(message);
    }
}
```



## 4. 异常处理

### 4.1 异常处理的两种方式

第一种方式：声明异常（throws关键字）

* 在方法定义时使用throws关键字声明异常，告知调用者，调用这个方法可能会出现异常。如果出现了异常则会抛给调用者（方法）来处理：

  `public void m() throws AException, BException... {}`

* 如果AException和BException都继承了XException，那么也可以这样写：

  `public void m() throws XException{}`

* 调用者在调用m()方法时，编译器会检测到该方法上用throws声明了异常，表示可能会抛出异常，编译器会继续检测该异常是否为编译时异常，如果为编译时异常则必须在编译阶段进行处理，如果不处理编译器就会报错
* 如果所有位置都采用throws，包括main方法的处理态度也是throws，如果运行时出现了异常，最终异常是抛给了main方法的调用者（JVM），JVM则会终止程序的执行。因此为了保证程序在出现异常后不被中断，至少main方法不要再使用throws进行声明了
* 发生异常后，在发生异常的位置上，往下的代码是不会执行的，除非进行了异常的捕捉

第二种方式：捕捉异常 (try...catch...关键字)

* 在可能出现异常的代码上使用 try..catch 进行捕捉处理。其它方法如果调用这个方法，对于调用者来说是不知道这个异常发生的。因为这个异常被抓住并处理掉了

* 语法格式：

  ```java
  try{
  // 尝试执行可能会出现异常的代码
  // try块中的代码如果执行出现异常，出现异常的位置往下的代码是不会执行的，直接进入catch块执行
  }catch(AException e){
  // 如果捕捉到AException类型的异常，在这里处理
  }catch(BException e){
  // 如果捕捉到BException类型的异常，在这里处理
  }catch(XException e){
  // 如果捕捉到XException类型的异常，在这里处理
  }
  // 当try..catch..将所有发生的异常捕捉后，这里的代码是会继续往下执行的。
  ```

* 注意事项：

  * catch可以写多个。并且遵循自上而下，从小到大（这里的大小代表子父类的关系，父类大，子类小），如果是同级别，则不论先后

  * catch语句块可以看作是分支，try catch语句中，最多只有一个catch分支执行

  * Java7新特性：catch后面小括号中可以编写多个异常，使用运算符 “ | ” 隔开：

    `catch(AException | BException e){}`

  

### 4.2 异常处理方式的选用

* 异常在处理的整个过程中应该是：声明和捕捉联合使用

* 什么时候捕捉？什么时候声明？

  如果异常发生后需要调用者来处理的，需要调用者知道的，则采用声明方式。否则采用捕捉

  

## 5. 异常的常用方法

* `getMessage()`：这个方法可以获取当时创建异常对象时给异常构造方法传递的 `String message`参数的值

* `printStackTrace()`：打印异常堆栈信息
  * 异常信息的打印是符合栈数据结构的，也就是说主要看最上面的异常信息（栈顶），才能定位到根源
  * 采用多线程打印，输出顺序不一

## 6. 异常在开发中的应用

学习异常之前处理异常情况都如下处理：

```java 
if(xxx){
    System.out.println(xxx);
    reurn;
}
```

异常和return都能终止方法运行：

```java
public class ExceptionTest {
    public static void main(String[] args) {
        User user = new User();
        try {
            user.setAge(101);
        } catch (Exception e) {
            System.out.println(e.getMessage());
        }
    }
}

class User{
    private int age;
    public User(){
    }
    public User(int age) {
        this.age = age;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) throws Exception {
        
        if(age < 0 || age > 100){
            throw new Exception("年龄不合法");
        }
        this.age = age;
    }
}
```



## 7. finally语句块

* finally语句块中的代码是一定会执行的
* finally语句块不能单独使用，至少需要配合try语句块一起使用（可以不要catch）
* 通常在finally语句块中完成资源的释放
  * 资源释放的工作比较重要，如果资源没有释放会一直占用内存
  * 为了保证资源的关闭，也就是说：不管程序是否出现异常，关闭资源的代码一定要保证执行
  * 因此在finally语句块中通常进行资源的释放
* final、finally、finalize分别是什么？
  * final是一个关键字，修饰的类无法继承，修饰的方法无法覆盖，修饰的变量不能修改
  * finally是一个关键字，和try一起使用，finally语句块中的代码一定会执行
  * finalize是一个标识符，它是Object类中的一个方法名





























# 常用API

## 包装类

* **包装类的分类**
  
  * Java8针对八种基本数据类型提供相应的引用数据类型—包装类
  * 有了类的特点，就可以调用类中的方法
  
  | 8种基本数据类型 | 包装类                  |
  | :-------------- | :---------------------- |
  | byte            | java.lang.Byte          |
  | short           | java.lang.Short         |
  | int             | java.lang.**Integer**   |
  | long            | java.lang.Long          |
  | float           | java.lang.Float         |
  | double          | java.lang.Double        |
  | boolean         | java.lang.Boolean       |
  | char            | java.lang.**Character** |
  
  * 其中Integer使用最多，以它为代表进行学习



包装类中的6个数字类型都继承了Number类

Byte、Short、Integer、Long、Float、Double都继承了Number类，因此这些类中都有以下这些方法：

byteValue()

shortValue()

intValue()

longValue()

floatValue()

doubleValue()

这些方法的作用就是将包装类型的数据转换为基本数据类型。

包装类转换成基本数据类型的过程我们称为：拆箱 unboxing

Boolean的拆箱方法：booleanValue();

Character的拆箱方法：charValue();



**Integer的常量**

* 通过Integer提供的常量可以获取int的最大值和最小值：
  * 最大值：Integer.MAX_VALUE
  * 最小值：Integer.MIN_VALUE

* 当然，其它5个数字包装类也有对应的常量：
  * byte最大值：Byte.MAX_VALUE
  * byte最小值：Byte.MIN_VALUE
  * short最大值：Short.MAX_VALUE
  * short最小值：Short.MIN_VALUE
  * ......

**Integer的构造方法**

* Integer(int value)
  * Java9之后标记已过时，不建议使用。
  * 该构造方法可以将基本数据类型转换成包装类。这个过程我们称为装箱boxing

* Integer(String s)
  * Java9之后标记已过时，不建议使用。
  * 该构造方法可以将字符串数字转换成包装类。但字符串必须是整数数字，如果不是会出现异常：NumberFormatException

其它包装类的构造方法也是如此，例如Boolean的构造方法

Boolean(boolean value)

Boolean(String s)

以上两个构造方法也都在Java9的时候标记已过时。



**Integer的常用方法**

| 方法                                  | 说明                                                         |
| ------------------------------------- | ------------------------------------------------------------ |
| static int compare(int x, int y)      | 比较大小                                                     |
| static int max(int a, int b)          | 最大值                                                       |
| static int min(int a, int b)          | 最小值                                                       |
| **static int parseInt(String s) **    | **将字符串数字转换成数字类型。其它包装类也有这个方法：Double.parseDouble(String s)** |
| static String toBinaryString(int i)   | 获取数字二进制的字符串表示形式                               |
| static String toHexString(int i)      | 获取数字十六进制的字符串表示形式                             |
| static String toOctalString(int i)    | 获取数字八进制的字符串表示形式                               |
| int compareTo(Integer anotherInteger) | 比较大小，可见实现了Comparable接口                           |
| boolean equals(Object obj)            | 包装类已经重写了equals()方法                                 |
| String toString();                    | 包装类已经重写了toString()方法                               |
| int intValue()                        | 将包装类拆箱为基本数据类型                                   |
| static String toString(int i)         | 将基本数据类型转换成字符串                                   |
| static Integer valueOf(int i)         | 将基本数据类型转换成Integer                                  |
| static Integer valueOf(String s)      | 将字符串转换成Integer（这个字符串必须是数字字符串才行，不然出现NumberFormatException） |

```java
public class Test {

    @Test
    public void testBoxing(){
        Integer i1 = Integer.valueOf(100);
        System.out.println(i1);//100

        Integer i2 = Integer.valueOf("100");
        System.out.println(i2);//100

        // 注意：java.lang.NumberFormatException
        //Integer i3 = Integer.valueOf("abc");
    }

    @Test
    public void testToString(){
        // 将基本数据类型转换成String
        String str = Integer.toString(100);
        System.out.println(str);//100

        // 这种方式也行。
        int i = 100;
        String s = i + "";
        System.out.println(s);//100
    }

    @Test
    public void testUnBoxing(){
        // 装箱
        Integer i = new Integer(100);
        // 拆箱
        int num = i.intValue();
        System.out.println(num + 1);//101
    }
    @Test
    public void testEqualsAndToString(){
        // Integer以及其它的包装类都已经将equals和toString重写了。
        Integer a = new Integer(100);
        Integer b = new Integer(100);
        System.out.println(a == b); // false
        System.out.println(a.equals(b)); // true

        System.out.println(a.toString()); // 100
        System.out.println(b.toString()); // 100
    }

    @Test
    public void testToJinZhi(){
        int num = 20;
        System.out.println(num + "对应的十六进制" + Integer.toHexString(num));//20对应的十六进制14
        System.out.println(num + "对应的二进制" + Integer.toBinaryString(num));//20对应的二进制10100
        System.out.println(num + "对应的八进制" + Integer.toOctalString(num));//20对应的八进制24
    }

    @Test
    public void testParseInt(){
        // 注意避免这个异常：java.lang.NumberFormatException
        //int num1 = Integer.parseInt("123a");
        int num1 = Integer.parseInt("123");

        double num2 = Double.parseDouble("3.14");

        long num3 = Long.parseLong("560");

        System.out.println(num1 + 1);//124
        System.out.println(num2 + 1);//4.140000000000001
        System.out.println(num3 + 1);//561
    }

    @Test
    public void testMaxAndMin(){
        System.out.println(Integer.max(10, 20));//20
        System.out.println(Integer.min(10, 20));//10
    }

    @Test
    public void testCompare(){
        int result = Integer.compare(30, 20);
        int result1 = Integer.compare(10, 20);
        int result2 = Integer.compare(20, 20);
        System.out.println(result);//1
        System.out.println(result1);//-1
        System.out.println(result2);//0
    }
}
```



**String、int、Integer三种类型之间的互相转换**（String,double,Double转换原理相同）

![image-20240725231120659](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407252311949.png)



```java
public class Wrapper {
    public static void main(String[] args) {
        //包装类(Integer)->String
        Integer i = 100;

        //方式1
        String str1 = i + "";
        //方式2
        String str2 = i.toString();
        //方式3
        String str3 = String.valueOf(i);

        //String->包装类(Integer)
        String str4 = "12345";
        
        //方式1
        Integer i1 = Integer.parseInt(str4);//使用到自动装箱
        //方式2
        Integer i2 = new Integer(str4);//使用到Integer构造器
    }
}
```



**自动装箱和自动拆箱**

```java
/**
 * 关于自动装箱和自动拆箱
 *      1. Java5的新特性。
 *      2. 自动装箱和自动拆箱属于编译阶段的功能。
 *      3. 自动装箱：auto boxing
 *      4. 自动拆箱：auto unboxing
 *      5. 自动装箱和自动拆箱机制是为了方便写代码而存在的机制。
 *      6. 装箱：Integer i = new Integer(100);
 *      7. 拆箱：int num = i.intValue();
 */
public class IntegerTest {
    public static void m1(Integer i){
        // 发生自动拆箱
        // 注意空指针异常。（注意排除空引用）
        if (i != null) {
            System.out.println(i + 1);
        }
    }

    public static void main(String[] args) {

        // 这个过程其实就发生了自动装箱。
        m1(10000);
        m1(null);

        // 自动装箱
        Integer x = 1000; // 程序在编译的时候底层实际上的代码是：Integer x = new Integer(1000);

        /*
        Integer a = 10000;
        Integer b = 10000;
        System.out.println(a == b); // false（堆当中两个Integer对象，内存地址不同。）*/

        // 自动拆箱
        int num = x; // 底层实际上会调用：int num = x.intValue();

        // 注意空指针：java.lang.NullPointerException
        /*
        x = null;
        int num2 = x; // int num2 = x.intValue();*/

    }
}
```

```java
public class wrapper {
    public static void main(String[] args) {
        //手动装箱 int->Integer
        int n1 = 10;
        Integer integer = new Integer(n1);//方式一
        Integer integer01 = Integer.valueOf(n1);//方式二

        //手动拆箱 Integer->int
        int i = integer.intValue();

        //自动装箱 int->Integer
        int n2 =20;
        Integer integer02 = n2;
        //自动拆箱 Integer->int
        int n3 = integer02;
    }
}
```



## Arrays

```java
/**
 * 测试数组工具类java.util.Arrays
 */
public class ArraysTest {
    
     /**
     * public static String toString(数组) : 将数组对象转换成字符串形式。
     */
    @Test
    public void testToString(){
        int[] arr = {1,2,3,34,54};
        System.out.println(arr); // [I@49e202ad
        System.out.println(Arrays.toString(arr)); // [1, 2, 3, 34, 54]

        String[] names = {"zhangsan", "lisi", "wangwu"};
        System.out.println(names); // [Ljava.lang.String;@641147d0
        System.out.println(Arrays.toString(names)); //[zhangsan, lisi, wangwu]
        
        Person p1 = new Person(20);
        Person p2 = new Person(22);
        Person p3 = new Person(19);
        Person p4 = new Person(18);
        Person[] persons = {p1, p2, p3, p4};
        System.out.println(persons);//[Lcom.powernode.javase.Person;@71248c21
        System.out.println(Arrays.toString(persons)); 
        //自定义Person中，需要重写toString方法，才能输出如下：
        //[Person{age=20}, Person{age=22}, Person{age=19}, Person{age=18}]
    }
    
    /**
     * public static String deepToString(Object[] a)作用是：适合于将多维数组转换成字符串。
     */
    @Test
    public void testDeepToString(){
        int[][] arr = {
                {1},
                {2,3},
                {4,5,6}
        };
        System.out.println(Arrays.toString(arr)); // [[I@49e202ad, [I@1c72da34, [I@6b0c2d26]
        System.out.println(Arrays.deepToString(arr)); // [[1], [2, 3], [4, 5, 6]]
    }

    
     /**
     * public static int[] copyOf(int[] 原数组, int 新数组长度)
     * 新数组长度<原数组长度：部分拷贝
     * 新数组长度=原数组长度：完全拷贝
     * 新数组长度>原数组长度：全部拷贝，多余位置补默认值
     *
     * public static int[] copyOfRange(int[] 原数组, int 起始索引, int 结束索引)
     */
    @Test
    public void testCopyOf(){
        
        int[] arr = {1,2,3,4,5,6,7,8,9};
        int[] newArr = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(newArr));//[1, 2, 3]

        // 不包含结束索引
        int[] newArr2 = Arrays.copyOfRange(arr, 2, 4);
        System.out.println(Arrays.toString(newArr2));//[3, 4]
    }
    
    /**
     * public static <T> List<T> asList(T... a)：将一组数据转换成List集合
     */
    @Test
    public void testAsList(){
        List list = Arrays.asList(1, 2, 3, 4, 5);
        for (int i = 0; i < list.size(); i++) {
            System.out.print(list.get(i) + " ");//1 2 3 4 5
        }
    }
    
     /**
     * 判断两个数组是否相等
     * public static boolean equals(int[] a, int[] a2)
     * public static boolean equals(Object[] a, Object[] a2)
     */
    @Test
    public void testEquals(){
        int[] arr1 = {1,2,3};
        int[] arr2 = {2,1,3};
        int[] arr3 = {1,2,3};
        System.out.println(Arrays.equals(arr1, arr2));//false
        System.out.println(Arrays.equals(arr1, arr3));//true

        String[] names1 = new String[]{"abc", "def", "xyz"};
        String[] names2 = new String[]{"abc", "def", "xyz"};
        System.out.println(Arrays.equals(names1, names2));//true
    }
    
     /**
     * 填充数组
     * public static void fill(int[] a, int val)
     * public static void fill(int[] a, int fromIndex, int toIndex, int val)
     */
    @Test
    public void testFill(){
        int[] arr = new int[5]; // 5个0
        Arrays.fill(arr, 10);
        System.out.println(Arrays.toString(arr));//[10, 10, 10, 10, 10]

        // 不包含toIndex
        Arrays.fill(arr, 1, 3, 100);
        System.out.println(Arrays.toString(arr));//[10, 100, 100, 10, 10]
    }
    
     /**
     * public static void sort(数组):给数组排序
     * 基本类型数组：默认升序
     * 自定义类型数组：自定义类必须实现Comparable接口，并且实现compareTo方法，在这个方法中编写比较规则
     */
    @Test
    public void testSort(){
        int[] arr = {3,6,7,2,4,1,5,9,8};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr));//[1, 2, 3, 4, 5, 6, 7, 8, 9]

        String[] strs = {"d", "c", "a", "b"};
        String[] strs1 = {"a", "ac", "ab", "b"};

        // 应该是根据字典的顺序排序的。
        Arrays.sort(strs);
        Arrays.sort(strs1);
        System.out.println(Arrays.toString(strs));//[a, b, c, d]
        System.out.println(Arrays.toString(strs1));//[a, ab, ac, b]

        // 能不能对Person数组排序
        Person p1 = new Person(20);
        Person p2 = new Person(22);
        Person p3 = new Person(19);
        Person p4 = new Person(18);
/*
如果自定义Person类没有实现Comparable接口，并且实现compareTo方法则会产生如下异常：java.lang.ClassCastException: class com.powernode.javase.Person cannot be cast to class java.lang.Comparable
猜测，底层一定有这样一行代码：
Comparable c = (Comparable) p1; 
为什么会报这样的错误呢？因为p1和c没有继承关系
也进一步说明了我们的Person类不是可比较的。
Comparable字面意思：可比较的。
*/
        Person[] persons = {p1, p2, p3, p4};

        Arrays.sort(persons);
        System.out.println(Arrays.toString(persons));
        //Person类实现Comparable接口，并且重写compareTo方法和toString方法后，输出如下：
        //[Person{age=18}, Person{age=19}, Person{age=20}, Person{age=22}]
    }
    
     /**
     * 启用多核CPU并行排序。
     * 首先你的电脑是支持多核的。
     * 注意：数据量太小的话，不要调用这个方法，因为启动多核也是需要耗费资源的。
     * Java8引入的方法。
     * 数据量较大的时候，建议使用这个方法效率比较高。
     * 通过源码分析：如果超过4096个长度，则会启用多核。
     * 4096以内就自动调用sort方法就行了。
     */
    @Test
    public void testParallelSort(){
        int[] arr = new int[100000000];
        Random random = new Random();//生成一个在 0 到 99999999 之间的随机整数
        for (int i = 0; i < arr.length; i++) {
            int num = random.nextInt(100000000);
            arr[i] = num;
        }

        // 获取系统当前时间的毫秒数（1970-1-1 0:0:0 000到当前系统时间的总毫秒数 1秒=1000毫秒）
        long begin = System.currentTimeMillis();

        // 排序
        Arrays.parallelSort(arr);//耗时2766
        //Arrays.sort(arr);//耗时9919
        // 获取系统当前时间的毫秒数
        long end = System.currentTimeMillis();

        // 耗时
        System.out.println(end - begin);
    }
    
    /**
     * public static int binarySearch(数组, 查找的元素)：二分查找法查找元素
     * 细节1：二分查找的前提:数组中的元素必须是升序的
     * 细节2：如果查找的元素是存在的，则返回真实索引；如果不存在，则返回的是 -插入点-1
     * 为什么要-1？
     * 如下述代码，我要查找数字0，此时0不存在，如果返回的是-插入点，即返回-0
     * 为避免这种情况，Java在这个基础上又减一
     */
    @Test
    public void testBinarySearch(){
        int[] arr = {1,2,3,4,5,6,7};
        System.out.println(Arrays.binarySearch(arr, 5));//4
        System.out.println(Arrays.binarySearch(arr, 0));//-1
        System.out.println(Arrays.binarySearch(arr, 8));//-8
    }
}
```

```java
public class Person implements Comparable{
    private int age;
    private String name;

    public Person() {
    }

    public Person(int age) {
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "age=" + age +
                '}';
    }

    @Override
    public int compareTo(Object o) {
        // 编写比较规则。
        // 根据年龄进行比较
        // p1.compareTo(p2) p1和p2之间进行比较。
        // this是p1
        // o是p2
        // 当前对象的年龄
        //this.age;

        // 另一个对象的年龄
        Person person = (Person) o;
        //person.age;

        // 按照年龄进行比较。
        return this.age - person.age;//按年龄升序
        //return person.age - this.age;//按年龄降序

        // 按照字符串进行比较。
        //String类已经实现Comparable接口以及实现compareTo方法
        // 升序
        //return this.name.compareTo(person.name);
        // 降序
        //return person.name.compareTo(this.name);
    }
}
```



## String

### String类概述

String 类代表字符串，Java 程序中的所有字符串文字（例如“abc”）都被实现为此类的实例。也就是说，Java 程序中所有的双引号字符串，都是 String 类的对象。String 类在 java.lang 包下，所以使用的时候不需要导包！

### String类的特点

* 在java程序当中，凡是带有双引号的字符串，在编译阶段就已经完全确定了：这些字符串字面量将来会放在字符串常量池中。在JVM启动的时候，会进行一系列的初始化，其中就包括字符串常量池的初始化，在初始化字符串常量池的时候，会将所有的字符串字面量全部提前创建好，放到字符串常量池中。在执行java程序的过程中，如果需要这个字符串字面量对象，直接从字符串常量池中获取，提高执行效率。字符串常量池是一种缓存技术。提前创建好对象放进去，用的时候直接拿。（字符串字面量在JVM启动的时候就会创建好）

* Java8之后：字符串常量池在堆内存当中

* 创建字符串对象两种方式的区别

  * 通过构造方法创建：通过 new 创建的字符串对象，每一次 new 都会申请一个内存空间，即使内容相同，但是地址值不同
  * 直接赋值方式创建：以“ ”方式给出的字符串，只要字符序列相同(顺序和大小写)，无论在程序代码中出现几次，JVM 都只会建立一个 String 对象，并在字符串池中维护。

  ```java
  public class StringTest {
      public static void main(String[] args) {
  
          String s1 = "hello";
          String s2 = "hello";
          System.out.println(s1 == s2); // true
  
          String s3 = "test";
          String s4 = new String("test");
          System.out.println(s3 == s4); // false
  
          // string重写了equals()：比较两个字符串内容是否相同、区分大小写
          System.out.println(s3.equals(s4)); // true
      }
  }
  ```

- 字符串一旦创建是不可变的

  ```java
  // x是可以变的。因为x只是一个普通的变量。可以指向其他字符串对象
  // 谁不能变？字符串字面量一旦创建不可变，在字符串常量池中。
  // "helloworld" 不能改变了。
  // "其他字符串" 不能改变了。
  String x = "helloworld";
  x = "其他字符串";
  ```

  原因：String源码中有一个属性：`private final byte[] value;`

  ​            数组一旦创建长度不可变；final修饰：value不能再指向其他对象；private修饰：类外无法访问;

- String的拼接

  ```java
  public class StringTest{
      public static void main(String[] args) {
          String s1 = "abc";
          String s2 = "def";
          String s3 = s1 + s2;
          String s4 = "abcdef"; 
          
          System.out.println(s3 == s4); // false
  		/*s3指向的对象，没有在字符串常量池中。在堆中。
  		底层实际上在进行 + 的时候，且这个 + 两边至少有一个是变量，会创建一个StringBuilder对象，进行字		符串的拼接，最后的时候会自动调用StringBuilder对象的toString()方法，再将StringBuilder转换成			String对象。*/
         
  
          /*以下程序中 + 两边都是字符串字面量，这种情况java对其进行优化：
          在编译的时候就会进行字符串的拼接，因此以下程序在字符串常量池中只有一个： “javatest” */
  		String x = "java" + "test"; // 等同于：String x = "javatest";
          String y = "javatest";
          System.out.println(x == y); // true
  
          // 以上程序中s3指向了堆中的一个字符串对象，并没有在常量池中。
          // 如果这个字符串使用比较频繁，希望将其加入到字符串常量池中，怎么办？
          String s5 = s3.intern();
          System.out.println(s4 == s5); // true
  
          String m = "m";
          String f = m + "e";
          String str = f.intern(); // 将"me"放入字符串常量池中，并且将"me"对象的地址返回。
  
          System.out.println(str == "me"); // true
  
      }
  }
  ```

  

### String类的构造方法

- 常用的构造方法

  | 方法名                                              | 说明                                                         |
  | --------------------------------------------------- | ------------------------------------------------------------ |
  | public String()                                     | 创建一个空白字符串对象，不含有任何内容                       |
  | public String(char[] value)                         | 根据字符数组创建一个新的字符串对象                           |
  | public String(char[] value, int offset, int count)  | 根据字符数组的指定部分创建一个新的字符串对象                 |
  | public String(byte[] bytes)                         | 根据字节数组创建一个新的字符串对象，默认使用平台默认的字符集进行解码 |
  | public String(byte[] bytes, int offset, int length) | 根据字节数组的指定部分创建一个新的字符串对象，默认使用平台默认的字符集进行解码 |
  | public String(byte[] bytes, String charsetName)     | 根据字节数组和指定的字符集名称创建一个新的字符串对象         |
  | public String(byte[] bytes, Charset charset)        | 根据字节数组和指定的字符集创建一个新的字符串对象             |
  | public String(String original)                      | 通过复制现有字符串创建一个新的字符串对象                     |

- 示例代码

  ```java
  public class StringTest{
      public static void main(String[] args) {
          //public String()：创建一个空白字符串对象，不含有任何内容
          String s1 = new String();
          System.out.println("s1:" + s1);//s1:
  
          //public String(char[] value) ：根据字符数组创建一个新的字符串对象
          char[] chs = {'a', 'b', 'c', 'd'};
          String s2 = new String(chs);
          System.out.println("s2:" + s2);//s2:abcd
          
          //public String(char[] value, int offset, int count)
          //根据字符数组的指定部分创建一个新的字符串对象
          String s3 = new String(chs,1,2);
          System.out.println("s3:" + s3);//s3:bc
  
          //public String(byte[] bytes)：根据字节数组创建一个新的字符串对象
          byte[] bytes = {97, 98, 99, 100};
          // 将byte[]数组转换成字符串String，是一个解码的过程。采用的是平台默认的字符编码方式进行的解码。
          String s4 = new String(bytes);
          System.out.println("s4:" + s4);//s4:abcd
          
  		//public String(byte[] bytes, int offset, int length)
          //将byte[]数组的一部分转换成字符串（解码的过程，也是采用平台默认的字符集。）
          String s5 = new String(bytes,1,2);
          System.out.println("s5:" + s5);//s5:bc
          
          // 乱码的本质：在进行编码和解码的时候没有使用同一个字符编码方式。
          // 先将字符串转换成byte[]数组（这个过程是一个编码的过程）
          // 这里先按照GBK的字符集进行编码。（GBK是简体中文）
          //byte[] bs = "你好，世界".getBytes("UTF-8");
          byte[] bs = "你好，世界".getBytes(StandardCharsets.UTF_8);
  
          // 将以上的byte[]数组转换成字符串（这个过程是一个解码的过程）
          //String s6 = new String(bs, "UTF-8");
          //根据字节数组和指定的字符集名称创建一个新的字符串对象
          String s6 = new String(bs, StandardCharsets.UTF_8);
  
          System.out.println("s6:" + s6);//s6:你好，世界
  
          // 在不知道字符编码方式的时候，可以动态获取平台的编码方式。（使用平台默认的字符集进行编码）
          byte[] bs2 = "世界和平".getBytes(Charset.defaultCharset());
  
          //使用平台默认的字符集进行解码。
          //根据字节数组和指定的字符集创建一个新的字符串对象
          String s7 = new String(bs2, Charset.defaultCharset());
          System.out.println("s7:" + s7);//s7:世界和平
  		
          // public String(String original)：复制现有字符串创建一个新的字符串对象
          //这个方法被@IntrinsicCandidate标注，这个注解是Java16引入的,作用是告诉编译器,该方法或构造函		  数是一个内在的候选方法,可以被优化和替换为更高效的代码。因此它是不建议使用的
          String s8 = new String("STRING"); // 底层会有两个对象，一个是"STRING"在字符串常量池中。一个是在堆内存中。浪费内存。
  		System.out.println("s8:" + s8);//s8:STRING
      }
  }
  ```

### String的常用方法

| 方法名                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| char charAt(int index)                                       | 返回索引处的char值                                           |
| int length()                                                 | 获取字符串长度                                               |
| boolean isEmpty()                                            | 判断字符串是否为空字符串，如果length()是0就是空字符串,指向null的String变量不是空，使用该方法会报错 |
| boolean equals(Object anObject)                              | 判断两个字符串是否相等                                       |
| boolean equalsIgnoreCase(String  anotherString )             | 判断两个字符串是否相等，忽略大小写                           |
| boolean contains(CharSequence s)                             | 判断当前字符串中是否包含某个子字符串                         |
| boolean startsWith(String prefix)                            | 判断当前字符串是否以某个字符串开头                           |
| boolean endsWith(String suffix)                              | 判断当前字符串是否以某个字符串结尾                           |
| int compareTo(String anotherString)                          | 两个字符串按照字典顺序比较大小                               |
| int compareToIgnoreCase(String str)                          | 两个字符串按照字典顺序比较大小，比较时忽略大小写             |
| int indexOf(String str)                                      | 获取当前字符串中str字符串第一次出现处的下标                  |
| int indexOf(String str, int fromIndex)                       | 从当前字符串的fromIndex下标开始（包括fromIndex）往右搜索，获取当前字符串中str字符串第一次出现处的下标 |
| int lastIndexOf(String str)                                  | 获取当前字符串中str字符串的最后一次出现处的下标              |
| int lastIndexOf(String str, int fromIndex)                   | 从当前字符串的fromIndex下标开始（包括fromIndex）往左搜索，获取当前字符串中str字符串最后一次出现处的下标（最后指的是当前字符串从左往右，左为前，右为后） |
| byte[] getBytes()                                            | 将字符串转换成字节数组。其实就是对字符串进行编码。默认按照系统默认字符集 |
| byte[] getBytes(String charsetName)                          | 将字符串按照指定名称的字符集的方式进行编码                   |
| byte[] getBytes(Charset charset)                             | 将字符串按照指定字符集的方式进行编码                         |
| char[] toCharArray()                                         | 将字符串转换字符数组                                         |
| String toLowerCase()                                         | 转小写                                                       |
| String toUpperCase()                                         | 转大写                                                       |
| String concat(String str)                                    | 进行字符串的拼接操作；和 + 的区别？ ①+ 既可以进行求和，也可以进行字符串的拼接，底层拼接时会创建StringBuilder对象进行拼接。+ 拼接null时不会出现空指针异常（直接把null当字符串拼接了）                                                                                                              ②concat方法参数只能是字符串类型，拼接时不会创建StringBuilder对象，拼接完成后返回一个新的String对象。拼接null会出现空指针异常。③+ 使用较多。如果进行大量字符串拼接，这两个都不合适 |
| String substring(int beginIndex)                             | 从指定下标beginIndex开始（包括beginIndex）截取子字符串       |
| String substring(int beginIndex, int endIndex)               | 从指定下标beginIndex开始（包括）到指定下标endIndex结束（不包括）截取子字符串 |
| String trim()                                                | 去除字符串前后空白（只能去除ASCII码中的空格和制表符）        |
| String strip()                                               | 去除字符串前后空白（支持所有的编码形式的空白，可以将全角空格去除，\u3000是全角空格 |
| String stripLeading()                                        | 去除前空白                                                   |
| String stripTrailing()                                       | 去除后空白                                                   |
| String intern()                                              | 获取字符串常量池中的字符串，如果常量池中没有，则将字符串加入常量池并返回 |
| static String join(CharSequence d, CharSequence... elements) | 将多个字符串以某个分隔符连接                                 |
| static String valueOf(boolean b)                             | 以下所有的静态方法valueOf作用是将非字符串类型的数据转换为字符串形式 |
| static String valueOf(char c)                                |                                                              |
| static String valueOf(char[] data)                           |                                                              |
| static String valueOf(char[] data, int offset, int count)    |                                                              |
| static String valueOf(double d)                              |                                                              |
| static String valueOf(int i)                                 |                                                              |
| static String valueOf(Object obj)                            | 自定义类要重写toString方法                                   |

### String常见面试题

```java
/**
 * String类常见的面试题。
 */
public class StringExam {
    @Test
    public void test1() {
        String s1 = "abc";
        String s2 = new String("abc");
        System.out.println(s1 == s2); // false
        System.out.println(s1.equals(s2)); // true
    }

    @Test
    public void test2() {
        // 这种拼接会在编译阶段完成。编译器优化策略。
        String s1 = "a" + "b" + "c";
        String s2 = "abc";
        System.out.println(s1 == s2); // true
    }

    @Test
    public void test3() {
        String s1 = "abc";
        String s2 = "ab";
        String s3 = s2 + "c";
        System.out.println(s1 == s3); // false
        System.out.println(s1.equals(s3)); // true
    }

    @Test
    public void test4() {
        // 问题：创建了几个对象？
        // 字符串常量池中1个
        String s1 = "a";
        // 字符串常量池中1个 ，堆1个。
        String s2 = new String("b");
        // 堆中2个。（拼接时创建一个StringBuilder对象，再创建一个String对象接收拼接后的字符串）
        String s3 = s1 + s2;
    }

    @Test
    public void test5() {
        // 问题：创建了几个对象？
        // 6个对象
        // 字符串常量池中2个
        // StringBuilder1个
        // 堆中的String 3个。
        String s = new String("a") + new String("b");
    }

    @Test
    public void test6() {
        // 这个程序会出现异常吗？如果没有异常，结果是什么？
        // 不会出现异常，结果是：nullnull
        String s1 = null;
        String s2 = s1 + null;
        //底层：String s2 = String.valueOf(s1) + null;
        System.out.println(s2);
    }

    @Test
    public void test7() {

        String s1 = "ab";
        
        final String s2 = "b";
        String s3 = "a" + s2;
        //加了final代表常量，编译的时候就放常量池，上两行代码等同于：String s3 = "a" + "b";

        System.out.println(s1 == s3);//true
    }

    @Test
    public void test8() {

        String s1 = "ab";

        final String s2 = getB();//尽管加了final,但等号右边是方法，在运行期才会执行
        String s3 = "a" + s2;

        System.out.println(s1 == s3); // false
    }

    public String getB() {
        return "b";
    }

    @Test
    public void test9() {
        String s1 = "a1";
        String s2 = "a" + 1;//1是字面量，同样能优化
        System.out.println(s1 == s2); // true
    }

    @Test
    public void test10() {
        String s1 = new String("abc");
        System.out.println(s1);

        StringBuilder s2 = new StringBuilder("abc");
        System.out.println(s2);

        // String的equals方法中，类型不一样，没有比较的意义。
        // s2是StringBuilder类型，类型不一样，结果一定是false。
        System.out.println(s1.equals(s2)); // false
    }
}
```



### StringBuilder和StringBuffer

StringBuffer和StringBuilder：可变长度字符串

* 这两个类是专门为频繁进行字符串拼接而准备。

- StringBuffer先出现的，Java5的时候新增了StringBuilder。**StringBuffer是线程安全的**。在不需要考虑线程安全问题的情况下优先选择StringBuilder，效率较高一些。

- 底层是 byte[] 数组，并且这个 byte[] 数组没有被final修饰，这说明如果byte[]数组满了，可以创建一个更大的新数组来达到扩容，然后它可以重新指向这个新的数组对象。

- 扩容原理：

  1、无参调用时，字符串默认初始容量为16.

  2、 a、当添加字符串不超过容量时，容量不发生变化，长度为字符串长度。

  ​       b、当添加字符串超过容量时，容量发生变化，计算公式为：

  ​             添加后容量=当前容量*2+2

  ​             适用于添加字符串长度+加上本身长度< 当前容量*2+2 的情况；

  ​       c、当添加的字符串超过 当前容量*2+2 时：

  ​             添加后容量=字符串长度+当前容量

  3、StringBuilder存储对象，说白了就是底层了byte数组在进行存储。

  我们在实际应用中应当避免StringBuilder频繁的扩容，节约资源，如果将来有需要使用StringBuilder方法添加字符串，且不知道添加多少时，可以使用StringBuilder(int capacity)方法构建一个没有字符的初始容量为capacity的字符串构造器，避免资源浪费。

  

StringBuffer、StringBuilder、String 中都实现了 CharSequence 接口。CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。

StringBuffer、StringBuilder、String 对 CharSequence 接口的实现过程不一样，如下图所示：

　　![img](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407261548505.png)

 

可见，String 直接实现了 CharSequence 接口，StringBuilder 和 StringBuffer 都是可变的字符序列，它们都继承于 AbstractStringBuilder，实现了 CharSequence 接口



**StringBuffer和StringBuilder构造方法**

| 构造方法名                      | 说明                                                         |
| ------------------------------- | ------------------------------------------------------------ |
| String Builder()                | 构造一个字符串生成器，其中不包含任何字符，初始容量为16个字符。 |
| String Builder (int capacity)   | 构造一个字符串生成器，其中不包含任何字符，并且具有由容量参数指定的初始容量。 |
| String Builder(String str)      | 构造初始化为指定字符串内容的字符串生成器                     |
| StringBuilder(CharSequence seq) | 接收CharSequence                                             |

**StringBuffer和StringBuilder常用方法**

| 方法名                                                | 说明                                               |
| ----------------------------------------------------- | -------------------------------------------------- |
| StringBuilder append(Type data)                       | Type为任意类型，添加数据，并返回对象本身           |
| StringBuilder deleteCharAt(int index)                 | 删除指定索引的字符，并返回对象本身                 |
| StringBuilder delete(int start, int end)              | 删除指定索引区间（左闭右开）的字符，并返回对象本身 |
| StringBuilder insert(int offset, String str)          | 指定位置插入字符串                                 |
| StringBuilder replace(int start, int end, String str) | 将指定索引区间（左闭右开）的字符由str替代          |
| StringBuilder reverse()                               | 反转字符                                           |
| void setCharAt(int index, char ch)                    | 将指定索引位置的字符设为传入的ch                   |
| void setLength(int newLength)                         | 设置长度                                           |

同String,也有以下常用方法：

char charAt(int index);

int indexOf(String str);

int indexOf(String str, int fromIndex);

int lastIndexOf(String str);

int lastIndexOf(String str, int fromIndex);

int length();

String substring(int start);

String substring(int start, int end);

String toString();

```java
/**
 * 测试java.lang.StringBuilder的相关方法
 */
public class StringBuilderTest {

    @Test
    public void testAppend(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.append("abc");
        s.append(new Object());
        s.append(false);
        s.append(3.14);

        System.out.println(s.toString());//10abcjava.lang.Object@442675e1false3.14
        System.out.println(s);//同上
    }
    
    @Test
    public void testDelete(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.append("abc");
        s.append(new Object());
        s.append(false);
        s.append(3.14);
        System.out.println(s);//10alang.Object@442675e1false3.14
        // [3 , 10)
        s.delete(3,10);
        System.out.println(s);//10alang.Object@442675e1false3.14

        s.deleteCharAt(0);
        System.out.println(s);//0alang.Object@442675e1false3.14
    }
    
    @Test
    public void testInsert(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.append("abc");
        s.insert(3, "hello world");
        System.out.println(s);//10ahello worldbc
    }
    
    @Test
    public void testReplace(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.append("abc");
        s.insert(3, "hello world");
        System.out.println(s);//10ahello worldbc

        s.replace(3, "hello world".length() + 3, "动力节点");
        System.out.println(s);//10a动力节点bc
    }
    
    @Test
    public void testReverse(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.append("abc");
        s.insert(3, "hello world");
        System.out.println(s);//10ahello worldbc
        s.replace(3, "hello world".length() + 3, "动力节点");
        System.out.println(s);//10a动力节点bc
        s.reverse();
        System.out.println(s);//cb点节力动a01
    }
    
    @Test
    public void testSetCharAt(){
        StringBuilder s = new StringBuilder();
        s.append(10);
        s.setCharAt(0, 'A');
        System.out.println(s);//A0
    }
    
    @Test
    public void testSetLength(){
        StringBuilder s = new StringBuilder();
        s.append("aaa111111111111111111111111111111111111111111111111111111");
        System.out.println(s);//aaa111111111111111111111111111111111111111111111111111111

        // 谨慎使用，会把已有的数据抹掉。
        s.setLength(3);
        System.out.println(s);//aaa
    }
}
```



### 链式编程

```java
public class StringBuilderDemo4 {
    public static void main(String[] args) {
        //1.创建对象
        StringBuilder sb = new StringBuilder();

        //2.添加字符串
        sb.append("aaa").append("bbb").append("ccc").append("ddd");
        //sb.append()返回的数据类型还是 StringBuilder，故可用链式编程

        System.out.println(sb);//aaabbbcccddd

        //3.再把StringBuilder变回字符串
        String str = sb.toString();
        System.out.println(str);//aaabbbcccddd

    }
}
```



## Math

java.lang.Math 数学工具类，都是静态方法

```java
/**
 * java.lang.Math 数学类。
 * 常用属性：static final double PI（圆周率）
 * 常用方法：
 * static int abs(int a);			绝对值
 * static double ceil(double a);	向上取整
 * static double floor(double a);	向下取整
 * static int max(int a, int b);	最大值
 * static int min(int a, int b);	最小值
 * static double random();		随机数[0.0, 1.0)     
   int num = (int)(Math.random() * 100);可以获取[0-100)的随机数
 * static long round(double a);		四舍五入
 * static double sqrt(double a);	平方根
 * static double pow(double a, double b);   a的b次幂
 */
public class MathTest {
    public static void main(String[] args) {
        // 圆周率
        System.out.println("圆周率：" + Math.PI);//圆周率：3.141592653589793

        // 绝对值
        int a = 100;
        int b = 396;
        System.out.println("相差：" + Math.abs(a - b));//相差：296

        // 向上取整
        System.out.println(Math.ceil(1.3));//2.0

        // 向下取整
        System.out.println(Math.floor(1.9999));//1.0

        // 取大值
        System.out.println(Math.max(10, 20));//20

        // 取小值
        System.out.println(Math.min(10, 20));//10

        // 四舍五入
        System.out.println(Math.round(3.4));//3
        System.out.println(Math.round(3.5));//4

        // 平方根
        System.out.println(Math.sqrt(9));//3.0
        System.out.println(Math.sqrt(10));//3.1622776601683795

        // a的b次幂
        System.out.println(Math.pow(2, 3));//8.0
        
        // 随机数[0.0 ~ 1.0)
        for (int i = 0; i < 10; i++) {
            System.out.println((int)(Math.random() * 100));
        }
    }
}
```

## Random

java.util.Random 随机数生成器（生成随机数的工具类）

```java
/**
 * 专门生成随机数的一个类：java.util.Random;
 * 常用构造方法：
 *          Random()
 * 常用方法：
 *          int nextInt(); 获取一个int类型取值范围内[-2147483648 ~ 2147483647]的随机int数
 *          int nextInt(int bound); 获取[0,bound)区间的随机数
 *          double nextDouble(); 获取[0.0, 1.0)的随机数。
 */
public class RandomTest {
    public static void main(String[] args) {

        // 获取一个随机数生成器对象
        Random random = new Random();

        for (int i = 0; i < 10; i++) {
            // 生成[-2147483648 ~ 2147483647]
            int num = random.nextInt();
            System.out.println(num);
        }

        System.out.println("===========================");

        // nextInt(int bound)
        // nextInt(101) 取[0, 100] 之间的随机数
        for (int i = 0; i < 10; i++) {
            int num = random.nextInt(101);
            System.out.println(num);
        }

        // nextDouble() [0.0 ~ 1.0)
        for (int i = 0; i < 10; i++) {
            double num = random.nextDouble();
            System.out.println(num);
        }
    }
}
```

## System

```java
java.lang.System 系统类。
 * 常用属性：
 * static final PrintStream err 标准错误输出流（System.err.println(“错误信息”);输出红色字体）
 * static final InputStream in 标准输入流
 * static final PrintStream out 标准输出流
    
 * 常用方法：
 * static void arraycopy(Object src,int srcPos,Object dest,int destPos,int length); 数组拷贝
 * static void exit(int status); 退出虚拟机
 * static void gc(); 建议启动垃圾回收器
 * static long currentTimeMillis(); 获取自1970-01-01 00:00:00 000到系统当前时间的总毫秒数
 * static long nanoTime(); 获取自1970年1月1日0时0分0秒以来，当前时间的纳秒数
 * static Map<String,String> getenv(); 获取当前系统的环境变量，例如Path，JAVA_HOME，CLASSPATH等。
 * static Properties getProperties(); 获取当前系统的属性。
 * static String getProperty(String key); 通过key获取指定的系统属性。

```



## 日期相关API

* **java.util.Date 日期类**

  * 构造方法：Date()
  * 构造方法：Date(long 毫秒)

  ```java
  // 注意：我们学习的是java.util.Date.
  // 不是java.sql.Date（java.sql.Date的父类是java.util.Date）
  import java.util.Date;
  
  /**
   * java.util.Date 日期API。
   */
  public class DateTest01 {
      public static void main(String[] args) {
          // Date类的构造方法
          // Date()
          // Date(long l)
  
          // 获取系统当前时间
          Date date = new Date();
          System.out.println(date);//Fri Jul 12 15:25:23 CST 2024
          //CST表示东八区时区，与UTC全球标准时间差8小时
  
          // 获取指定的时间（参数的单位是毫秒数）
          Date date1 = new Date(1000);
          System.out.println(date1);//Thu Jan 01 08:00:01 CST 1970
  
          // 获取当前系统时间的前10分钟时间
          Date date2 = new Date(System.currentTimeMillis());
          //long l = System.currentTimeMillis();
          //获取自1970年1月1日0时0分0秒到系统当前时间的总毫秒数。
          System.out.println(date2);//Fri Jul 12 15:25:23 CST 2024
  
          Date date3 = new Date(System.currentTimeMillis() - 1000 * 60 * 10);
          System.out.println(date3);//Fri Jul 12 15:15:23 CST 2024
      }
  }
  ```



* **java.util.SimpleDateFormat 日期格式化类**

  ```java
  import java.text.ParseException;
  import java.text.SimpleDateFormat;
  import java.util.Date;
  
  /**
   * 日期格式化，需要借助：
   *      java.text.DateFormat
   *      java.text.SimpleDateFormat（用这个。DateFormat是SimpleDateFormat的父类。）
   */
  public class DateTest02 {
      public static void main(String[] args) throws ParseException {
  
          // java.util.Date ---> java.lang.String
          // 获取系统当前时间
          Date now = new Date();
  
          // 格式化
          //SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
          //SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yyyy");
          //SimpleDateFormat sdf = new SimpleDateFormat("dd/MM/yy");
          SimpleDateFormat sdf = new SimpleDateFormat("HH:mm:ss");
  
          // 调用format方法完成格式化
          String str = sdf.format(now);
  
          System.out.println(str);//15:33:57
  
  
          // java.lang.String ---> java.util.Date
          // 日期字符串
          String strDate = "2008-08-08 08:08:08 888";
  
          // 创建日期格式化对象
          SimpleDateFormat sdf2 = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss SSS");
  
          // 解析：将字符串String转换成Date
          Date date = sdf2.parse(strDate);
  
          System.out.println(date);//Fri Aug 08 08:08:08 CST 2008
  
      }
  }
  ```



* **java.util.Calendar 日历类**

  * 获取当前时间的日历对象：Calendar c = Calendar.getInstance();
  * 获取日历中的某部分：int year = c.get(Calendar.YEAR);

  ```java
  import java.util.Calendar;
  
  public class CalendarTest01 {
      public static void main(String[] args) {
  
          // 获取当前时间的日历对象（调用一个静态方法）
          Calendar calendar = Calendar.getInstance();
          System.out.println(calendar);
  
          // 获取日历中的年
          int year = calendar.get(Calendar.YEAR);
          System.out.println(year);
  
          // 获取日历中的月
          int month = calendar.get(Calendar.MONTH);
          System.out.println(month); // 0-11 表示一年中的12个月。
  
          // 获取日历中的日
          int day = calendar.get(Calendar.DAY_OF_MONTH);
          System.out.println(day);
  
          /*
              Calendar.YEAR 获取年份
              Calendar.MONTH 获取月份，0表示1月，1表示2月，...，11表示12月
  
              Calendar.DAY_OF_MONTH 获取本月的第几天
              Calendar.DAY_OF_YEAR 获取本年的第几天
              Calendar.DAY_OF_WEEK 获取星期几，1表示星期日，...，7表示星期六
  
              Calendar.HOUR_OF_DAY 小时，24小时制
              Calendar.HOUR 小时，12小时制
  
              Calendar.MINUTE 获取分钟
              Calendar.SECOND 获取秒
              Calendar.MILLISECOND 获取毫秒
  
           */
      }
  }
  ```

  * 日历的set方法：设置日历

    * calendar.set(Calendar.YEAR, 2023);  

    * calendar.set(2008, Calendar.SEPTEMBER,8);

  * 日历的add方法（日历中各个部分的加减）

    * calendar.add(Calendar.YEAR, 1);

  * 日历对象的setTime()让日历关联具体的时间

    * calendar.setTime(new Date());

  * 日历对象的getTime()方法获取日历的具体时间：

    * Date time = calendar.getTime();

  ```java
  public class CalendarTest02 {
      public static void main(String[] args) throws ParseException {
          // 获取系统当前时间的日历
          Calendar cal = Calendar.getInstance();
          // 设置该日历的年是2008年
          cal.set(Calendar.YEAR, 2008);
          //cal.set(Calendar.MONTH, 10);
          // 获取日历的年月日信息
          System.out.println(cal.get(Calendar.YEAR) + "年" + (cal.get(Calendar.MONTH) + 1) + "月" + cal.get(Calendar.DAY_OF_MONTH) + "日");
          // 设置日历是2008年8月8日 8时8分8秒的日历
          cal.set(2008, Calendar.AUGUST,8,8,8,8);
          // 获取日历的年月日信息
          System.out.println(cal.get(Calendar.YEAR) + "年" + (cal.get(Calendar.MONTH) + 1) + "月" + cal.get(Calendar.DAY_OF_MONTH) + "日");
  
          // 年加1
          //cal.add(Calendar.YEAR, 2);
          cal.add(Calendar.YEAR, -2);
          // 获取日历的年月日信息
          System.out.println(cal.get(Calendar.YEAR) + "年" + (cal.get(Calendar.MONTH) + 1) + "月" + cal.get(Calendar.DAY_OF_MONTH) + "日");
  
          // 获取一个2008年5月12日 15:30:30的Date
          String strDate = "2008-05-12 15:30:30";
          SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
          Date date = sdf.parse(strDate);
          cal.setTime(date);
          // 获取这个日历的小时和分
          System.out.println(cal.get(Calendar.HOUR_OF_DAY));
          System.out.println(cal.get(Calendar.MINUTE));
  
          // 获取日历代表的日期
          cal.set(Calendar.SECOND, 56); // 修改日历中的秒
          Date time = cal.getTime();
          String s = sdf.format(time);
          System.out.println(s);
  
      }
  }
  ```

  

## Java8的新日期API

传统的日期API存在线程安全问题，Java8又提供了一套全新的日期API

java.time.LocalDate 日期、java.time.LocalTime 时间、java.time.LocalDateTime 日期时间 

java.time.Instant 时间戳信息

java.time.Duration 计算两个时间对象之间的时间间隔，精度为纳秒

java.time.Period 计算两个日期之间的时间间隔，以年、月、日为单位

java.time.temporal.TemporalAdjusters 提供了一些方法用于方便的进行日期时间调整

java.time.format.DateTimeFormatter 用于进行日期时间格式化和解析



### 1. LocalDate日期、LocalTime时间、LocalDateTime日期时间

* 获取当前时间（精确到纳秒，1秒=1000毫秒，1毫秒=1000微秒，1微秒=1000纳秒）

  ```java
  LocalDateTime now = LocalDateTime.now();
  ```

* 获取指定日期时间

  ```java
  LocalDateTime ldt = LocalDateTime.of(2008,8,8,8,8,8,8); // 获取指定的日期时间
  ```

* 加日期和加时间

  ```java
  LocalDateTime localDateTime = ldt.plusYears(1).plusMonths(1).plusDays(1).plusHours(1).plusMinutes(1).plusSeconds(1).plusNanos(1);
  ```

* 减日期和减时间 

  ```java
  LocalDateTime localDateTime = ldt.minusYears(1).minusMonths(1).minusDays(1).minusHours(1).minusMinutes(1).minusSeconds(1).minusNanos(1);
  ```

* 获取年月日时分秒

  ```java
  int year = now.getYear(); // 年			
  int month = now.getMonth().getValue(); // 月
  int dayOfMonth = now.getDayOfMonth(); // 一个月的第几天	
  int dayOfWeek = now.getDayOfWeek().getValue(); // 一个周第几天
  int dayOfYear = now.getDayOfYear(); // 一年的第几天	
  int hour = now.getHour(); // 时
  int minute = now.getMinute(); // 分			
  int second = now.getSecond(); // 秒
  int nano = now.getNano(); // 纳秒
  ```

### 2. Instant 时间戳

```java
/**
 * 获取时间戳：自1970-1-1 0时0分0秒到当前系统时间的总毫秒数。
 */
public class DateTest {
    public static void main(String[] args) {
        
        Instant now = Instant.now(); // 系统当前时间，基于UTC（全球标准时间）
        System.out.println(now);//2024-07-12T08:13:25.513824300Z

        long epochMilli = now.toEpochMilli();
        System.out.println("时间戳：" + epochMilli);//时间戳：1720772005513
    }
}
```

### 3. Duration 计算时间间隔

```java
public class DateTest {
    public static void main(String[] args) {
        // 获取时间1
        LocalDateTime time1 = LocalDateTime.of(2008, 7, 8, 8, 8, 8);
        // 获取时间2
        LocalDateTime time2 = LocalDateTime.of(2008, 8, 8, 8, 8, 8);
        // 获取两个时间的差
        Duration between = Duration.between(time1, time2);
        // 看看差多少天
        System.out.println("相差天数：" + between.toDays());//相差天数：31
        // 看看差多少个小时
        System.out.println("相差小时：" + between.toHours());//相差小时：744
    }
}
```



### 4. Period 计算日期间隔

```java
public class DateTest {
    public static void main(String[] args) {

        LocalDate date1 = LocalDate.of(2007,7,15);
        LocalDate date2 = LocalDate.of(2008,8,8);
        
        // 计算两个日期差
        Period between = Period.between(date1, date2);
        // 相差的年
        System.out.println(between.getYears());//1
        // 相差的月
        System.out.println(between.getMonths());//0
        // 相差的日
        System.out.println(between.getDays());//24
    }
}
```

### 5. TemporalAdjusters  时间矫正器

```java
import java.time.DayOfWeek;
import java.time.LocalDateTime;
import java.time.temporal.TemporalAdjusters;

/**
 * LocalDateTime now = LocalDateTime.now(); // 获取系统当前时间
 * now.with(TemporalAdjusters.firstDayOfMonth()); // 当前月的第一天
 * now.with(TemporalAdjusters.firstDayOfNextYear()); // 下一年的第一天
 * now.with(TemporalAdjusters.lastDayOfYear()); // 本年最后一天
 * now.with(TemporalAdjusters.lastDayOfMonth()); // 本月最后一天
 * now.with(TemporalAdjusters.next(DayOfWeek.MONDAY)); // 下周一
 * ......
 */
public class DateTest {
    public static void main(String[] args) {
        // 获取系统当前时间
        LocalDateTime now = LocalDateTime.now();
        // 矫正时间
        LocalDateTime localDateTime1 = now.with(TemporalAdjusters.lastDayOfYear());
        System.out.println(localDateTime1);
    }
}
```



### 6. DateTimeFormatter 日期格式化

```java
public class DateTest {
    public static void main(String[] args) {

        // LocalDateTime -> String
        // 获取一个日期时间
        LocalDateTime now = LocalDateTime.now();
        // 创建格式化对象
        DateTimeFormatter dateTimeFormatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        // 格式化
        String s = dateTimeFormatter.format(now);
        System.out.println(s);

        // String -> LocalDateTime
        LocalDateTime localDateTime = LocalDateTime.parse("2008-08-08 08:08:08", dateTimeFormatter);
        System.out.println(localDateTime);
    }
}
```



## 大数字

### BigInterger  

如果整数超过long的最大值怎么办？

* java中提供了一种引用数据类型来解决这个问题：java.math.BigInteger。它的父类是Number

* 常用构造方法：BigInteger(String val)

* 常用方法：

  * BigInteger add(BigInteger val)：求和
  * BigInteger subtract(BigInteger val)： 相减
  * BigInteger multiply(BigInteger val)：乘积
  * BigInteger divide(BigInteger val)：商
  * int compareTo(BigInteger val)：比较
  * BigInteger abs()：绝对值
  * BigInteger max(BigInteger val)：最大值
  * BigInteger min(BigInteger val)：最小值
  * BigInteger pow(int exponent)：次幂
  * BigInteger sqrt()：平方根

  ```java
  public class BigNumTest01 {
      public static void main(String[] args) {
  
          // 编译报错，超范围。
          //long num = 99999999999999999999999L;
  
          // 创建一个大整数
          BigInteger num1 = new BigInteger("-99999999999999999999999");
          System.out.println(num1);//-99999999999999999999999
  
          BigInteger num2 = new BigInteger("1");
  
          // 加法
          BigInteger result1 = num1.add(num2);
          System.out.println(result1);//-99999999999999999999998
  
          // 减法
          BigInteger result2 = num1.subtract(num2);
          System.out.println(result2);//-100000000000000000000000
  
          // 乘法
          BigInteger result3 = num1.multiply(num2);
          System.out.println(result3);//-99999999999999999999999
  
          // 除法
          BigInteger result4 = num1.divide(num2);
          System.out.println(result4);//-99999999999999999999999
  
          // 绝对值
          BigInteger result5 = num1.abs();
          System.out.println(result5);//99999999999999999999999
  
          // 次幂
          BigInteger bigInteger = new BigInteger("2");
          BigInteger pow = bigInteger.pow(3);
          System.out.println(pow);//8
          
          //平方根
          BigInteger bigInteger1 = new BigInteger("9");
          BigInteger sqrt = bigInteger1.sqrt();
          System.out.println(sqrt);//3
  
      }
  }
  ```

  

### BigDecimal

如果浮点型数据超过double的最大值怎么办？

* java中提供了一种引用数据类型来解决这个问题：java.math.BigDecimal（经常用在财务软件中）。它的父类是Number

* 构造方法：BigDecimal(String val)

* 常用方法：

  * BigDecimal add(BigDecimal augend);		求和
  * BigDecimal subtract(BigDecimal subtrahend);	相减
  * BigDecimal multiply(BigDecimal multiplicand);	乘积
  * BigDecimal divide(BigDecimal divisor);		商
  * BigDecimal max(BigDecimal val);		最大值
  * BigDecimal min(BigDecimal val);		最小值
  * BigDecimal movePointLeft(int n);		向左移动小数点
  * BigDecimal movePointRight(int n);		向右移动小数点

  ```java
  public class BigNumTest02 {
      public static void main(String[] args) {
          BigDecimal num1 = new BigDecimal("10");
          BigDecimal num2 = new BigDecimal("2");
  
          System.out.println(num1.add(num2));//12
          System.out.println(num1.subtract(num2));//8
          System.out.println(num1.multiply(num2));//20
          System.out.println(num1.divide(num2));//5
          System.out.println(num1.max(num2));//10
          System.out.println(num1.min(num2));//2
  
          BigDecimal num3 = new BigDecimal("123456789.123456789");
          System.out.println(num3.movePointLeft(3));//123456.789123456789
          System.out.println(num3.movePointRight(3));//123456789123.456789
      }
  }
  ```

### 数字格式化

* 有时我们需要将数字以某种格式展示，java.text.DecimalFormat 类是专门用来对数字进行格式化的
* 常用数字格式：
  * ###,###.##   （三个数字为一组，组和组之间使用逗号隔开，保留两位小数）
  * ###,###.0000  （三个数字为一组，组和组之间使用逗号隔开，保留4位小数，不够补0）

* 构造方法：DecimalFormat(String pattern)；
* 常用方法：String format(数字)；

```java
public class DecimalFormatTest {
    public static void main(String[] args) {

        // 创建一个数字格式化对象
        DecimalFormat df = new DecimalFormat("###,###.##");

        // 格式化
        String s = df.format(12345678.123);

        System.out.println(s); // "12,345,678.12"

        // 保留四位小数，要求不够补0
        DecimalFormat df2 = new DecimalFormat("###,###.0000");
        String s2 = df2.format(12345678.123);
        System.out.println(s2); // "12,345,678.1230"
    }
}
```

## UUID

UUID（通用唯一标识符）是一种软件构建的标准，用来生成具有唯一性的ID。

UUID具有以下特点：

* UUID可以在分布式系统中生成唯一的标识符，避免因为主键冲突等问题带来的麻烦。
* UUID具有足够的唯一性，重复的概率相当低。UUID使用的是128位数字，除了传统的16进制表示之外（32位的16进制表示），还有基于62进制的表示，可以更加简洁紧凑。
* UUID生成时不需要依赖任何中央控制器或数据库服务器，可以在本地方便、快速地生成唯一标识符。
* UUID生成后可以被许多编程语言支持并方便地转化为字符串表示形式，适用于多种应用场景。在Java开发中，UUID的使用是非常普遍的。它可以用于生成数据表主键、场景标识、链路追踪、缓存Key等。使用UUID可以方便地避免主键、缓存Key等因冲突而产生的问题，同时能够实现多种功能，例如追踪、缓存、日志记录等。

```java
/**
 * Java中的java.util.UUID类提供对UUID的支持
 * 生成UUID：static UUID randomUUID();
 * 将UUID转换为字符串：String toString();
 */public class UUIDTest {
    public static void main(String[] args) {

        // 获取UUID对象
        UUID uuid = UUID.randomUUID();

        String s = uuid.toString();

        System.out.println(s);//306356c5-a816-42da-ae4d-a10772fe7008

        String s1 = s.replaceAll("-", "").toUpperCase();

        System.out.println(s1);//306356C5A81642DAAE4DA10772FE7008
    }
}
```



## Lambda表达式

![ec6533fbfcc663b195b7c886fc40f44](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031632131.png)

![e6816f5825de4fb89ab96ba5943d618](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407031632009.png)

![2ddceebae68b753392d3e3a8e866baa](javanote01.assets/2ddceebae68b753392d3e3a8e866baa.png)

![fd21ab09065d703e58af09324d15996](javanote01.assets/fd21ab09065d703e58af09324d15996.png)

# 集合

## 集合概述

* 集合是一种容器，用来组织和管理数据的。Java的集合框架对应的这套类库其实就是对各种数据结构的实现
* 集合中存储的是引用，不是把堆中的对象存储到集合中，是把对象的地址存储到集合中。
* 默认情况下，**如果不使用泛型的话**，集合中可以存储任何类型的引用，只要是Object的子类都可以存储
* Java集合框架相关的类都在 java.util 包下
* **集合与数组的对比：**
  * 数组长度固定；集合长度可变
  * 数组可以存储基本类型和引用类型；集合只能存储引用类型，基本类型要转成包装类

## 集合体系结构

* 集合主要分两组：

  * 单列集合（Collection）：元素以单个形式存储

  * 双列集合（Map）：元素以键值对的映射关系存储



## 单列集合

### 体系结构图

![image-20240807144221383](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408071442843.png)

注：

* SequencedCollection和SequencedSet接口都是Java21新增的接口
* 有色的是实现类。其它的都是接口
* 实现类中只有HashSet是无序集合。剩下的都是有序集合
  * 有序集合：集合中存储的元素有下标**或者**集合中存储的元素是可排序的。
  * 无序集合：集合中存储的元素没有下标**并且**集合中存储的元素也没有排序。

* List集合中存储的元素可重复。Set集合中存储的元素不可重复。



List系列集合：添加的元素是有序、可重复、有索引

Set系列集合：添加的元素是无序、不重复、无索引

有序指的是存取顺序

### Collection

#### 常用方法

| 方法                          | 说明                                   |
| ----------------------------- | -------------------------------------- |
| boolean add(E e);             | 向集合中添加元素                       |
| int size();                   | 获取集合中元素个数                     |
| boolean isEmpty();            | 判断集合中元素个数是否为0              |
| boolean contains(Object o);   | 判断集合中是否包含对象o                |
| Object[] toArray();           | 将集合转换成一维数组                   |
| boolean remove(Object o);     | 从集合中删除对象o                      |
| boolean addAll(Collection c); | 将参数集合中所有元素全部加入当前集合   |
| void clear();                 | 清空集合                               |
| Iterator<E> iterator();       | 方法继承自Iterable接口，获取迭代器对象 |

ps:

* Collection方法集成了Set和List，故操作对象都是元素，无索引操作
* add( )方法中：
  * 如果往List系列集合添加元素，方法永远返回true
  * 如果往Set系列集合添加元素，若要添加元素不存在，方法返回true；**若要添加元素已经存在，方法返回false**
* remove( )方法中，删除成功，则返回true；删除失败，则返回false，元素不存在就会删除失败；通过hashCode和equals找key
* contains( )方法中，底层是依赖equals方法进行判断是否存在的，所以，如果集合中存储的是自定义对象，也想通过contains方法来判断是否包含，那么在自定义类中一定要重写equals方法，重写后的方法是根据对象属性来判断；如果没有重写equals方法，则默认使用Object类中的equals方法进行判断，默认equals方法是依赖地址值进行判断，无意义

#### Collection的遍历

##### 1.迭代器遍历

Iterator接口的常用方法：

| 方法               | 说明                                           |
| ------------------ | ---------------------------------------------- |
| boolean hasNext(); | 判断光标指向位置是否有元素                     |
| E next();          | 先返回光标指向位置的元素，再将光标向下移动一位 |
| void remove()      | 删除元素                                       |



```java
第一步：获取集合依赖的迭代器对象
Iterator it = collection.iterator();

第二步：判断当前光标指向的位置是否存在元素
boolean has = it.hasNext();
true:表示当前光标指向的位置有数据。
false:表示当前光标指向的位置没有数据。
    
第三步：取出当前光标指向位置的元素，并且将光标向下移动一位。
Object obj = it.next();
```

![9b5cf836c6cc50641ee4861e76148a9](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408071557420.png)

迭代器细节：

* 当前位置没有元素，还要强行获取，会报异常
* 迭代器遍历完毕，指针不会复位
* 循环中只能用一次next方法

##### 2.增强 for 遍历

```java
for (元素数据类型 变量名 ：数组或单列集合){}
```

* 循环内不会改变集合内元素
* 增强for的底层就是迭代器，为了简化迭代器的代码
* 只有数组和单列集合才能用



##### 3.Lambda 表达式遍历

```java
public class CollectionDemo {
    public static void main(String[] args) {
       /* 
        lambda表达式遍历：
        Iterable 接口中的方法：default void forEach(Consumer<? super T> action)
        */

        //1.创建集合并添加元素
        Collection<String> coll = new ArrayList<>();
        coll.add("zhangsan");
        coll.add("lisi");
        coll.add("wangwu");
        //2.利用匿名内部类的形式
        //底层原理：
        //其实也会自己遍历集合，依次得到每一个元素
        //把得到的每一个元素，传递给下面的accept方法
        //s依次表示集合中的每一个数据
       /* coll.forEach(new Consumer<String>() {
            @Override
            public void accept(String s) {
                System.out.println(s);
            }
        });*/

        //lambda表达式
        coll.forEach(s -> System.out.println(s));
    }
}
```



#### **迭代时删除元素**

```java
public class CollectionTest {
    public static void main(String[] args) {

        // 创建集合对象
        Collection<String> names = new ArrayList<>();

        // 添加元素
        names.add("zhangsan");
        names.add("lisi");
        names.add("wangwu");
        names.add("zhaoliu");
        names.add("zhoubapi");

        // 迭代集合，删除集合中的某个元素
        Iterator<String> it = names.iterator();
        while (it.hasNext()) {
            String name = it.next(); // java.util.ConcurrentModificationException 并发修改异常 modCount expectedModCount
            if("lisi".equals(name)){
                // 删除元素（使用集合带的remove方法删除元素）
                //names.remove(name);
                // 删除元素（使用迭代器的remove方法删除元素）
                it.remove();//删除lisi
            }
            System.out.println(name);
        }

        System.out.println(names.size());
        System.out.println("============================");
        // 再次迭代
        Iterator<String> it2 = names.iterator();
        while (it2.hasNext()) {
            String name = it2.next();
            System.out.println(name);
        }
    }
}
```

* 迭代集合时删除元素
  * 使用“集合对象.remove(元素)”：会出现ConcurrentModificationException异常。
  * 使用“迭代器对象.remove()”：不会出现异常。

* 关于集合的并发修改问题
  * 想象一下，有两个线程：A和B。A线程负责迭代遍历集合，B线程负责删除集合中的某个元素。当这两个线程同时执行时会有什么问题？
* 如何解决并发修改问题：**fail-fast机制**
  * fail-fast机制又被称为：快速失败机制。也就是说只要程序发现了程序对集合进行了并发修改。就会立即让其失败，以防出现错误。

* fail-fast机制是如何实现的？以下是源码中的实现原理：
  * 集合中设置了一个modCount属性，用来记录修改次数，使用集合对象执行增，删，改中任意一个操作时，modCount就会自动加1。
  * 获取迭代器对象的时候，会给迭代器对象初始化一个expectedModCount属性。并且将expectedModCount初始化为modCount，即：int expectedModCount = modCount;
  * 当使用集合对象删除元素时：modCount会加1。但是迭代器中的expectedModCount不会加1。而当迭代器对象的next()方法执行时，会检测expectedModCount和modCount是否相等，如果不相等，则抛出：ConcurrentModificationException异常。
  * 当使用迭代器删除元素的时候：modCount会加1，并且expectedModCount也会加1。这样当迭代器对象的next()方法执行时，检测到的expectedModCount和modCount相等，则不会出现ConcurrentModificationException异常。

* 注意：虽然上面程序是单线程的程序，并没有使用多线程，但是通过迭代器去遍历的同时使用集合去删除元素，这个行为将被认定为并发修改。
* 结论：迭代集合时，删除元素要使用“迭代器对象.remove()”方法来删除，避免使用“集合对象.remove(元素)”。主要是为了避免ConcurrentModificationException异常的发生。**注意：迭代器的remove()方法删除的是next()方法返回的那个数据。remove()方法调用之前一定是先调用了next()方法，如果不是这样的，就会报错。**

* 在遍历的过程中需要删除元素就用迭代器，如果只是遍历，那么使用增强for或lambda表达式



### SequencedCollection接口

* SequencedCollection接口是Java21版本新增的。是所有有序集合的祖宗接口

* SequencedCollection接口中的方法：

```JAVA
void addFirst(Object o)：向头部添加

void addLast(Object o)：向末尾添加

Object removeFirst()：删除头部

Object removeLast()：删除末尾

Object getFirst()：获取头部节点

Object getLast()：获取末尾节点

SequencedCollection reversed(); 反转集合中的元素
```

除了HashSet 外，ArrayList，LinkedList，Vector，LinkedHashSet，TreeSet, Stack 都可以调用这个接口中的方法。

### 泛型

#### 泛型概述

* 泛型是Java5的新特性，属于编译阶段的功能。
* 泛型可以让开发者在编写代码时指定集合中存储的数据类型泛型作用：
  * 类型安全：指定了集合中元素的类型之后，编译器会在编译时进行类型检查，如果尝试将错误类型的元素添加到集合中，就会在编译时报错，避免了在运行时出现类型错误的问题。
  * 代码简洁：使用泛型可以简化代码，避免了繁琐的类型转换操作。比如，在没有泛型的时候，需要使用 Object 类型来保存集合中的元素，并在使用时强制类型转换成实际类型，而有了泛型之后，只需要在定义集合时指定类型即可。

* 在集合中使用泛型

  `Collection<String> strs = new ArrayList<String>();`

  这就表示该集合只能存储字符串，存储其它类型时编译器报错。并且以上代码使用泛型后，避免了繁琐的类型转换，集合中的元素可以直接调用String类特有的方法。

* Java7的新特性：

  钻石表达式：`Collection<String> strs = new ArrayList<>();`



#### **泛型的擦除与补偿（了解）**

* 泛型的出现提高了编译时的安全性，正因为编译时对添加的数据做了检查，则程序运行时才不会抛出类型转换异常。因此泛型本质上是编译时期的技术，是专门给编译器用的。加载类的时候，会将泛型擦除掉（擦除之后的类型为Object类型），这个称为泛型擦除。
* 为什么要有泛型擦除呢？其本质是为了让JDK1.4和JDK1.5能够兼容同一个类加载器。在JDK1.5版本中，程序编译时期会对集合添加的元素进行安全检查，如果检查完是安全的、没有错误的，那么就意味着添加的元素都属于同一种数据类型，则加载类时就可以把这个泛型擦除掉，将泛型擦除后的类型就是Object类，这样擦除之后的代码就与JDK1.4的代码一致。
* 由于加载类的时候，会默认将类中的泛型擦除为Object类型，所以添加的元素就被转化为Object类型，同时取出的元素也默认为Object类型。而我们获得集合中的元素时，按理说取出的元素应该是Object类型，为什么取出的元素却是实际添加的元素类型呢？
* 这里又做了一个默认的操作，我们称之为泛型的补偿。在程序运行时，通过获取元素的实际类型进行强转，这就叫做泛型补偿（不必手动实现强制转换）。获得集合中的元素时，虚拟机会根据获得元素的实际类型进行向下转型，也就是会恢复获得元素的实际类型，因此我们就无需手动执行向下转型操作，从本质上避免了抛出类型转换异常。

#### **泛型的使用：在类上定义泛型**

语法：`class 类名<泛型1,泛型2,泛型3...>{}`

```java
public class Vip<NameType, AgeType> {
    private NameType name;
    private AgeType age;

    public Vip(NameType name, AgeType age) {
        this.name = name;
        this.age = age;
    }

    public NameType getName() {
        return name;
    }

    public void setName(NameType name) {
        this.name = name;
    }

    public AgeType getAge() {
        return age;
    }

    public void setAge(AgeType age) {
        this.age = age;
    }

    public static void main(String[] args) {
        // 创建Vip对象
        Vip<String, Integer> vip = new Vip<>("zhangsan", 20);

        // 编译报错
        //Vip<String, Integer> vip2 = new Vip<>("zhangsan", "20");

        String name = vip.getName();
        Integer age = vip.getAge();
        System.out.println(name);
        System.out.println(age);
    }
}
```

#### **泛型的使用：在静态方法上定义泛型**

* 在类上定义的泛型，在静态方法中无法使用。如果在静态方法中使用泛型，则需要在**方法返回值类型前面**进行泛型的声明。
* 语法格式：`<泛型1, 泛型2, 泛型3, ...> 返回值类型 方法名(形参列表) {}`

#### **泛型的使用：在接口上定义泛型**

语法格式：`interface 接口名<泛型1,泛型2,...> {}`

例如：public interface Flayable<T>{}

实现接口时，如果知道具体的类型，则：public class MyClass implements Flyable<Bird>{}

实现接口时，如果不知道具体的类型，则：public class MyClass<T> implements Flyable<T>{}

#### **泛型通配符**

* 泛型是在限定数据类型，当在集合或者其他地方使用到泛型后，那么这时一旦明确泛型的数据类型，那么在使用的时候只能给其传递和数据类型匹配的类型，否则就会报错。
* 有的情况下，我们在定义方法时，根本无法确定集合中存储元素的类型是什么。为了解决这个“无法确定集合中存储元素类型”问题，那么Java语言就提供了泛型的通配符。
* 通配符的几种形式：
  * 无限定通配符，<?>，此处“？”可以为任意引用数据类型。
  * 上限通配符，<? extends A>，此处“？”必须为A类及其子类。
  * 下限通配符，<? super B>，此处“？”必须为B类及其父类。

### List

List特有方法：

| 方法名                                       | 描述                                                         |
| -------------------------------------------- | ------------------------------------------------------------ |
| void add(int index, E  element)              | 在此集合中的指定位置插入指定的元素，原来索引及以后的元素依次往后移 |
| E remove(int   index)                        | 删除指定索引处的元素，返回被删除的元素                       |
| E set(int index, E  element)                 | 修改指定索引处的元素，返回被修改的元素                       |
| E get(int  index)                            | 返回指定索引处的元素                                         |
| int indexOf(Object o)                        | 获取对象o在当前集合中第一次出现时的索引                      |
| int lastIndexOf(Object o)                    | 获取对象o在当前集合中最后一次出现时的索引                    |
| List<E> subList(int fromIndex, int  toIndex) | 截取子List集合生成一个新集合（对原集合无影响），左闭右开     |
| static List<E> of (E... elements)            | 静态方法，返回包含任意数量元素的不可修改列表（获取的集合是只读的，不可修改的。） |




List集合的五种遍历方式

1. 迭代器（iterator）
2. 增强for
3. Lambda表达式
4. 普通for循环（配合get()方法）
5. List集合特有的迭代器（listIterator）

代码示例：

```java
//创建集合并添加元素
List<String> list = new ArrayList<>();
list.add("aaa");
list.add("bbb");
list.add("ccc");

//1.迭代器
/*Iterator<String> it = list.iterator();
     while(it.hasNext()){
        String str = it.next();
        System.out.println(str);
}*/


//2.增强for
//下面的变量s，其实就是一个第三方的变量而已。
//在循环的过程中，依次表示集合中的每一个元素
/* for (String s : list) {
       System.out.println(s);
   }*/

//3.Lambda表达式
//forEach方法的底层其实就是一个循环遍历，依次得到集合中的每一个元素
//并把每一个元素传递给下面的accept方法
//accept方法的形参s，依次表示集合中的每一个元素
//list.forEach(s->System.out.println(s) );


//4.普通for循环
//size方法跟get方法还有循环结合的方式，利用索引获取到集合中的每一个元素
/*for (int i = 0; i < list.size(); i++) {
            //i:依次表示集合中的每一个索引
            String s = list.get(i);
            System.out.println(s);
        }*/

// 5.列表迭代器
//获取一个列表迭代器的对象，里面的指针默认也是指向0索引的

//额外添加了一个方法：在遍历的过程中，可以添加元素
ListIterator<String> it = list.listIterator();
while(it.hasNext()){
    String str = it.next();
    if("bbb".equals(str)){
        //qqq
        it.add("qqq");
    }
}
System.out.println(list);
```

细节点注意：

List系列集合中的两个删除的方法

```java
1.直接删除元素
2.通过索引进行删除
```

代码示例:

```java
//List系列集合中的两个删除的方法
//1.直接删除元素
//2.通过索引进行删除

//1.创建集合并添加元素
List<Integer> list = new ArrayList<>();

list.add(1);
list.add(2);
list.add(3);


//2.删除元素
//请问：此时删除的是1这个元素，还是1索引上的元素？
//为什么？
//因为在调用方法的时候，如果方法出现了重载现象
//优先调用，实参跟形参类型一致的那个方法。

//list.remove(1);


//手动装箱，手动把基本数据类型的1，变成Integer类型
Integer i = Integer.valueOf(1);

list.remove(i);

System.out.println(list);
```



List集合的排序

* List接口中的方法：default void sort(Comparator<? super E> c);  对List集合中元素排序可以调用此方法。
* sort方法需要一个参数: java.util.Comparator。我们把这个参数叫做比较器。这是一个接口。
* 如何给自定义类型指定比较规则？可以对Comparator提供一个实现类，并重写compare方法来指定比较规则。
* 当然，Comparator接口的实现类也可以采用匿名内部类的方式。

```java
public class ListSort2 {
    public static void main(String[] args) {
        // 创建Person对象
        Person p1 = new Person("abc", 20);
        Person p2 = new Person("bbc", 18);
        Person p3 = new Person("abb", 19);
        Person p4 = new Person("cbc", 25);
        Person p5 = new Person("acb", 6);

        // 创建List集合
        List<Person> persons = new ArrayList<>();

        persons.add(p1);
        persons.add(p2);
        persons.add(p3);
        persons.add(p4);
        persons.add(p5);

        // 排序
        persons.sort(new Comparator<Person>() {
            @Override
            public int compare(Person o1, Person o2) {
                return o1.getAge() - o2.getAge();//升序
            }
        });


        for (int i = 0; i < persons.size(); i++) {
            System.out.println(persons.get(i));
        }
    }
}
```



### ArrayList

* ArrayList 可以加null，并且多个
* 线程不安全

构造方法：

public ArrayList()

public ArrayList(int initialCapacity)

public ArrayList(Collection<? extends E> c)



ArrayList 源码分析：

![image-20240818183402588](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408181834775.png)

![image-20240818183419599](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408181834793.png)

使用无参构造时，底层数组长度默认为0，当添加第一个元素时，开始扩容为***DEFAULT_CAPACITY* = 10**；

进行添加操作时，判断当元素个数与底层数组长度相等，会再次扩容，扩容规则：比较此次添加元素的个（minCapacity - oldCapacity）与默认新增容量（oldCapacity >>1: 数组扩容前的长度右移1位）的大小，谁大就扩容谁的大小；

当minCapacity - oldCapacity  < oldCapacity >>时：

相当于扩容**到**原始容量的1.5倍

当minCapacity - oldCapacity  > oldCapacity >>时：

相当于添加了多少元素就扩容多少

### LinkedList

* 底层双向链表
* 可以加null
* 线程不安全

### Vector

* 底层是数组
* Vector中所有方法都有synchronized修饰，线程同步，即线程安全
* 无参构造：public Vector() {this(10);} 则默认初始容量为10
* 扩容策略：扩容之后的容量是原容量的2倍

### 栈数据结构

* LIFO原则（Last In，First Out）：后进先出

* 实现栈数据结构，可以用数组来实现，也可以用双向链表来实现。

* 用数组实现的代表是：Stack、ArrayDeque

  * Stack：Vetor的子类，实现了栈数据结构，除了具有Vetor的方法，还扩展了其它方法，完成了栈结构的模拟。不过在JDK1.6（Java6）之后就不建议使用了，因为它是线程安全的，太慢了。Stack中的方法如下：
    * E push(E item)：压栈
    * E pop()：弹栈（将栈顶元素删除，并返回被删除的引用）
    * int search(Object o)：查找栈中元素（返回值的意思是：以1为开始，从栈顶往下数第几个）
    * E peek()：窥视栈顶元素（不会将栈顶元素删除，只是看看栈顶元素是什么。注意：如果栈为空时会报异常。）

  * ArrayDeque
    * E push(E item)
    * E pop()

* 用链表实现的代表是：LinkedList

  * LinkedList
    * E push(E item)
    * E pop()

### 队列数据结构

* 队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，队列是一种操作受限制的线性表。进行插入操作（入口）的端称为队尾，进行删除操作（出口）的端称为队头。

* 队列的插入操作只能在队尾操作，队列的删除操作只能在队头操作，因此队列是一种先进先出（First In First Out）的线性表，简称FIFO表。

* Queue接口是一种基于FIFO（先进先出）的数据结构，而Deque接口则同时支持FIFO和LIFO（后进先出）两种操作。因此Deque接口也被称为“双端队列”。

* Java集合框架中队列的实现：

  * 链表实现方式：LinkedList

  * 数组实现方式：ArrayDeque

* LinkedList和ArrayDeque都实现了Queue、Deque接口，因此这两个类都具备队列和双端队列的特性。

* LinkedList底层是基于双向链表实现的，因此它天然就是一个双端队列，既支持从队尾入队，从队头出队，也支持从队头入队，从队尾出队。用Deque的实现方式来说，就是它既实现了队列的offer()入队和poll()出队方法，也实现了双端队列的offerFirst()、offerLast()、pollFirst()和pollLast()方法等。

* ArrayDeque底层是使用环形数组实现的，也是一个双端队列。它比LinkedList更加高效，因为在数组中随机访问元素的时间复杂度是O(1)，而链表中需要从头或尾部遍历链表寻找元素，时间复杂度是O(N)。循环数组：index = (start + i) % capacity





### Set

Set接口继承Collection，没有任何新增任何方法

Set系列集合主要实现类：

HashSet：无序、不可重复

LinkedHashSet：有序（有下标）、不可重复

TreeSet：有序（可排序）、不可重复



#### HashSet

HashSet底层就是HashMap

往HashSet集合中存储元素，实际上是放到了HashMap集合的key部分。因此放在HashSet集合中的元素，要同时重写hashCode+equals

```java
/**
 * HashSet面试题
 */
public class HashSetExam {
    public static void main(String[] args) {
        // 创建HashSet集合（底层HashMap，哈希表数据结构）
        HashSet<Student> set = new HashSet<>();
        // 创建Student对象
        Student stu = new Student("张三", 18);
        // 添加Student对象
        set.add(stu);
        // 又添加了新的Student对象
        set.add(new Student("李四", 21));
        System.out.println(set);
        // 将张三学生的名字修改为王五
        // 虽然修改了，但是这个节点Node还是采用了之前 张三 的哈希值
        stu.setName("王五");
        // 问题1：请问是否删除了HashSet集合中的stu对象呢？？？
        // 不能删除
        set.remove(stu);
        //System.out.println(set);
        // 问题2：添加以下Student对象是否成功？？？
        // 可以添加成功
        set.add(new Student("王五", 18));
        //System.out.println(set);
        // 问题3：添加以下Student对象是否成功？？？
        // 可以添加成功
        set.add(new Student("张三", 18));
        System.out.println(set);
    }
}
```



#### LinkedHashSet

LinkedHashSet底层就是LinkedHashMap，所以底层是“哈希表+双向链表”。

LinkedHashSet集合存储元素特点：有序不可重复。有序指的是存进去的顺序和取出的顺序一样。

放进去的元素也需要重写hashCode+equals。

#### TreeSet

 * **TreeSet中不能存储null**

 * TreeSet集合存储元素特点：有序不可重复

 * 不可重复：hashCode + equals需要重写

 * TreeSet集合有序：可排序

 * 两种排序的方式：

    * 第一种：存放在HashSet集合中的元素实现 java.lang.Comparable接口。

    * 第二种：创建HashSet集合的时候，给构造方法传递一个比较器： java.util.Comparator的实现类。																																																																																								

![b655038b5e067db332f4953d9302bf2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408190129683.png)

## 双列集合

### 体系结构图

![image-20240818212409271](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182124476.png)

### Map

* Map集合以key和value的键值对形式存储。key和value存储的**都是引用**
* Map集合中key起主导作用。value是附属在key上的
* SequencedMap是Java21新增的
* LinkedHashMap和TreeMap都是有序集合。（key是有序的）
* HashMap，Hashtable，Properties都是无序集合。（key是无序的）
* Map集合的key都是不可重复的。key重复的话，value会覆盖
* HashSet集合底层是new了一个HashMap。往HashSet集合中存储元素实际上是将元素存储到HashMap集合的key部分。HashMap集合的key是无序不可重复的，因此HashSet集合就是无序不可重复的。HashMap集合底层是哈希表/散列表数据结构，因此HashSet底层也是哈希表/散列表
* TreeSet集合底层是new了一个TreeMap。往TreeSet集合中存储元素实际上是将元素存储到TreeMap集合的key部分。TreeMap集合的key是不可重复但可排序的，因此TreeSet集合就是不可重复但可排序的。TreeMap集合底层是红黑树，因此TreeSet底层也是红黑树。它们的排序通过java.lang.Comparable和java.util.Comparator均可实现
* LinkedHashSet集合底层是new了一个LinkedHashMap。LinkedHashMap集合只是为了保证元素的插入顺序，效率比HashSet低，底层采用的哈希表+双向链表实现。根据源码可以看到向Set集合中add时，底层会向Map中put。value只是一个固定不变的常量，只是起到一个占位符的作用。主要是key

#### Map常用方法

| 方法名                                                       | 说明                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| V put(K key, V value);                                       | 添加键值对；若键不存在，则将键值对对象加到集合中，返回null；若键已经存在，则将原有的键值对对象覆盖，返回原有键值对对象中的value |
| void putAll(Map<? extends K,? extends V> m);                 | 添加多个键值对                                               |
| V get(Object key);                                           | 通过key获取value                                             |
| void clear();                                                | 清空Map                                                      |
| boolean containsKey(Object key);                             | 是否包含某个key                                              |
| boolean containsValue(Object value);                         | 是否包含某个value                                            |
| int size();                                                  | 键值对个数                                                   |
| boolean isEmpty();                                           | 判断是否为空Map                                              |
| V remove(Object key);                                        | 通过key删除key-value                                         |
| Collection<V> values();                                      | 获取所有的value                                              |
| Set<K> keySet();                                             | 获取所有的key                                                |
| Set<Map.Entry<K,V>> entrySet();                              | 获取所有键值对的Set视图                                      |
| static <K,V> Map<K,V> of(K k1, V v1, K k2, V v2, K k3, V v3); | 静态方法，使用现有的key-value构造Map                         |

interface Entry<K, V> {

K getKey();

V getValue();

}

![image-20240818215630045](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182156150.png)



#### Map的遍历方式

1. 键找值

   ![image-20240818221200000](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182212126.png)

   

2. 键值对

   ![image-20240818221229260](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182212401.png)

   

3. Lambda表达式

   ![image-20240818221242402](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182212540.png)

### 哈希表存储原理

哈希表：一种数据结构的名字。

哈希函数：通过哈希函数可以将一个Java对象映射为一个数字。（就像现实世界中，每个人（对象）都会映射一个身份证号（哈希值）一样。）也就是说通过哈希函数的执行可以得到一个哈希值。

在Java中，hashCode()方法就是哈希函数。也就是说hashCode()方法的返回值就是哈希值。

一个好的哈希函数，可以让散列分布均匀。

哈希值：也叫做哈希码。是哈希函数执行的结果。

哈希碰撞：也叫做哈希冲突。当两个对象“哈希值%数组长度”之后得到的下标相同时，就发生了哈希冲突。

如何解决哈希冲突？

将冲突的挂到同一个链表上或同一个红黑树上。

以上描述凡是“哈希”都可以换为“散列”。

**重点：**

**存放在HashMap集合key部分的元素，以及存储在HashSet集合中的元素，都需要同时重写hashCode+equals方法**

**equals返回true时，hashCode必须相同**

![7e4d70c03875172152cdc8c0a5ac6d8](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182305720.png)

### HashMap

* HashMap集合的key是无序不可重复的。无序：插入顺序和取出顺序不一定相同。不可重复：key具有唯一性。
* 底层的数据结构是：哈希表/散列表，哈希表可能是：数组 + 链表，数组 + 红黑树， 数组 + 链表 + 红黑树等。
* 线程不安全
* HashMap的key可以为null，只能有一个，value也可以为null,可以有多个
* 向HashMap集合中put时，key如果重复的话，value会覆盖

![image-20240818231038436](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182310563.png)





### LinkedHashMap

* LinkedHashMap集合和HashMap集合的用法完全相同。
* 不过LinkedHashMap可以保证插入顺序。
* LinkedHashMap集合因为可以保证插入顺序，因此效率比HashMap低一些。
* LinkedHashMap是如何保证插入顺序的？底层采用了双向链表来记录顺序。
* LinkedHashMap集合底层采用的数据结构是：哈希表 + 双向链表。
* LinkedHashMap集合的key是：有序不可重复。key部分也需要同时重写hashCode + equals。
* key的取值可以为null，key如果相同，value也是覆盖。

![image-20240818235149556](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408182351688.png)



### Hashtable

* 使用方法基本和HashMap一样，底层也是哈希表
* Hashtable是**线程安全**的，方法上都有synchronized关键字。使用较少，因为保证线程安全有其他方式
* Hashtable的初始化容量：11
* 默认加载因子：0.75
* Hashtable的扩容策略：2倍
* **键和值都不能为NULL**



### Properties

 * **键和值都不能为NULL**

 * java.util.Properties，我们一般叫做：属性类。

 * Properties继承Hashtable，所以Properties也是线程安全的。Properties也是一个Map集合。

 * Properties属性类一般和java程序中的属性配置文件联合使用，属性配置文件的扩展名是：xxxxxxx.properties

 * Properties类不支持泛型。**key和value是固定类型，都是String类型**。

 * 目前需要掌握的Properties三个方法：

   * String value = pro.getProperty("name"); 和put方法一样

   * pro.setProperty("name", "value"); 通过key获取value

   * Enumeration names = pro.propertyNames(); 获取所有的key 



### TreeMap

* 可排序：按照元素的默认规则（由小到大）排序，不可重复
* TreeMap底层就是红黑树
* TreeMap和HashMap用法一样，只不过需要key排序的时候，就可以使用TreeMap
* TreeMap集合的key也需要重写hashCode + equals（保证不可重复）
* **TreeMap的key不能是null，value可以是null**
* 让TreeMap自定义类型的key可排序，有两种方式：
  * 第一种方式：key实现了Comparable接口，并且提供了compareTo方法，在该方法中添加了比较规则。(比较规则不变的话建议这种。)
  * 第二种方式：创建TreeMap集合时，传一个比较器，比较器实现Comparator接口，在compare方法中添加比较规则。

## Collections

Collection不是集合，是集合工具类

![image-20240819020210539](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408190202092.png)























# 多线程

进程：程序的基本执行实体

线程：操作系统能够进行运算调度的最小单位，包含在进程之中，是进程的实际运作单位



并行： 在同一时刻，多个指令在多个CPU上同时进行

并发：在同一时间段，多个指令在单个CPU上交替执行



## 实现多线程的三种方式

1.继承Thread类

```java
//步骤
//1.自定义一个类MyThread继承Thread类
//2.在MyThread类中重写run()方法
//3.创建MyThread类的对象
//4.调用start()方法开启线程
public class MyThread extends Thread {
    @Override
    public void run() {
        for(int i=0; i<100; i++) {
            System.out.println(i);
        }
    }
}
public class MyThreadDemo {
    public static void main(String[] args) {
        MyThread my1 = new MyThread();
        MyThread my2 = new MyThread();

        my1.start();
        my2.start();
    }
}
```

2.实现Runnable接口

```java
//步骤
//1.自定义一个类MyRunnable实现Runnable接口
//2.在MyRunnable类中重写run()方法
//3.创建MyRunnable类的对象
//4.创建Thread类的对象，把MyRunnable对象作为构造方法的参数
//5.调用start()方法开启线程
public class MyRunnable implements Runnable {
    @Override
    public void run() {
        for(int i=0; i<100; i++) {
            System.out.println(Thread.currentThread().getName()+":"+i);
        }
    }
}
public class MyRunnableDemo {
    public static void main(String[] args) {
        MyRunnable my = new MyRunnable();
        Thread t1 = new Thread(my);
        Thread t2 = new Thread(my);
        t1.start();
        t2.start();
    }
}
```

3.利用Callable接口和Future接口

```java
//步骤
//1.定义一个类MyCallable实现Callable接口
//2.在MyCallable类中重写call()方法
//3.创建MyCallable类的对象
//4.创建Future的实现类FutureTask对象，把MyCallable对象作为构造方法的参数
//5.创建Thread类的对象，把FutureTask对象作为构造方法的参数
//6.启动线程
//7.再调用get方法，就可以获取线程结束之后的结果。
public class MyCallable implements Callable<String> {
    @Override
    public String call() throws Exception {
        for (int i = 0; i < 100; i++) {
            System.out.println("跟女孩表白" + i);
        }
        //返回值就表示线程运行完毕之后的结果
        return "答应";
    }
}
public class Demo {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        //线程开启之后需要执行里面的call方法
        MyCallable mc = new MyCallable();
        
        FutureTask<String> ft = new FutureTask<>(mc);
        
        Thread t1 = new Thread(ft);
        t1.start();
        
        String s = ft.get();
        System.out.println(s);
    }
}
```

![d76010950d17812177d4235321a64b5](javanote01.assets/d76010950d17812177d4235321a64b5.png)



## 线程优先级

线程调度

- 两种调度方式
  - 分时调度模型：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间片
  - 抢占式调度模型：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个，优先级高的线程获取的 CPU 时间片相对多一些

- Java使用的是抢占式调度模型

优先级线程默认优先级是5；线程优先级的范围是：1-10（10代表优先级最高，表示抢到cpu概率是大的，但也仅仅是概率）

## 线程的生命周期

![fdda97278806a32dd54af7f5a53a5f5](javanote01.assets/fdda97278806a32dd54af7f5a53a5f5.png)

## 生产者和消费者（等待唤醒机制）

## 线程池

![f32b507767e036a82106eb3fc22bf27](javanote01.assets/f32b507767e036a82106eb3fc22bf27.png)

# IO流

## IO流概述

1. 什么是IO流？

* IO流指的是：程序中数据的流动。数据可以从内存流动到硬盘，也可以从硬盘流动到内存
* Java中IO流最基本的作用是：完成文件的读和写

2. IO流的分类

* 根据数据流向分为：输入和输出是相对于内存而言的
  * 输入流：从硬盘到内存。(输入又叫做读：read)
  * 输出流：从内存到硬盘。（输出又叫做写：write）

* 根据读写数据形式分为：

  * 字节流：一次读取一个字节。适合读取非文本数据。例如图片、声音、视频等文件。（当然字节流是万能的。什么都可以读和写。）
  * 字符流：一次读取一个字符。只适合读取普通文本。不适合读取二进制文件。因为字符流统一使用Unicode编码，可以避免出现编码混乱的问题。

  **注意：Java中的所有IO流中凡是以Stream结尾的都是字节流。凡是以Reader和Writer结尾的都是字符流。**

* 根据流在IO操作中的作用和实现方式来分类：
  * 节点流：节点流负责数据源和数据目的地的连接，是IO中最基本的组成部分
  * 处理流：处理流对节点流进行装饰/包装，提供更多高级处理操作，方便用户进行数据处理

3. Java中已经将io流实现了，在**java.io**包下，可以直接使用

## IO流的体系结构

![ad59ba03080870fc7d57af94ba418a5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407131458678.png)

* 上图是常用的IO流。实际上IO流远远不止这些。
* InputStream：字节输入流
* OutputStream：字节输出流
* Reader：字符输入流
* Writer：字符输出流
* 以上4个流都是抽象类，是所有IO流的四大头领！
* 所有的流都实现了Closeable接口，都有close()方法，流用完要关闭
* 所有的**输出流**都实现了Flushable接口，都有flush()方法，flush方法的作用是，将缓存清空，全部写出。养成好习惯，以防数据丢失。





## 对象流

**ObjectOutputStream和ObjectInputStream**

① 通过这两个流，可以完成对象的序列化和反序列化

② 序列化(Serial)：将Java对象转换为字节序列。（为了方便在网络中传输），使用ObjectOutputStream序列化

③ 反序列化(DeSerial)：将字节序列转换为Java对象。使用ObjectInputStream进行反序列化

![image-20240715224418003](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202407152244631.png)





## File

* 创建文件

  ```java
  
  import org.junit.jupiter.api.Test;
  
  import java.io.File;
  import java.io.IOException;
  
  public class CreatFile {
      public static void main(String[] args) {
      }
      @Test
      //方式1 new File(String pathname)
      public void create01(){
          String filepath = "D:\\news1.txt";
          File file = new File(filepath);
          try {
              file.createNewFile();
              System.out.println("文件创建成功");
          } catch (IOException e) {
              throw new RuntimeException(e);
          }
  
      }
      @Test
      //方式2 new File(File parent, String child) 父目录文件＋子路径
      public void create02(){
          File parentfile = new File("D:\\");
          String fileName = "news2.txt";
          File file = new File(parentfile, fileName);
          try {
              file.createNewFile();
              System.out.println("创建成功");
          } catch (IOException e) {
              throw new RuntimeException(e);
          }
      }
      @Test
      //方式3 new File(String parent, String child) 父目录＋子路径
      public void create03(){
          String parentPath = "d:/";
          String fileName = "news3.txt";
          File file = new File(parentPath, fileName);
          try {
              file.createNewFile();
              System.out.println("创建成功");
          } catch (IOException e) {
              throw new RuntimeException(e);
          }
  
      }
  }
  ```

  

  

  

  
  
## 节点流和处理流

## 输入流

## 输出流

## Properties类





# 反射

反射机制允许程序在执行期借助子Reflection API取得任何类的内部信息(比如成员变量，构造器，成员方法等等)，并能操作对象的属性及方法

加载完类之后,在堆中就产生了一个Class类型的对象(一个类只有一个Class对象)，这个对象包含了类的完整结构信息。通过这个对象得到类的结构。这个对象就像一面镜子,透过这个镜子看到类的结构 所以,形象的称之为：反射

# 动态代理





