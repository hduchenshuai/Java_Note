# 集合

## ArrayList扩容机制

使用无参构造时，底层数组长度默认为0，当添加第一个元素时，开始扩容为***DEFAULT_CAPACITY* = 10**；

进行添加操作时，判断当元素个数与底层数组长度是否相等，相等时会再次扩容，扩容规则：比较此次添加元素的个数（minCapacity - oldCapacity）与默认新增容量（oldCapacity >>1: 数组扩容前的长度右移1位）的大小，谁大就扩容谁的大小；

当minCapacity - oldCapacity  < oldCapacity >>1时：

相当于扩容**到**原始容量的1.5倍

当minCapacity - oldCapacity  > oldCapacity >>时：

相当于添加了多少元素就扩容多少

## HashMap在Java8前后区别

* 初始化时机：
  * Java8之前：构造方法执行时初始化table数组。
  * Java8之后：第一次调用put方法时初始化table数组。

* 插入法：
  * Java8之前：头插法
  * Java8之后：尾插法

* 数据结构：
  * Java8之前：数组 + 单向链表
  * Java8之后：数组 + 单向链表 + 红黑树；最开始使用单向链表解决哈希冲突。如果结点数量 **>= 8**，并且table的长度 **>= 64**。单向链表转换为红黑树。当删除红黑树上的结点时，结点数量 **<= 6** 时。红黑树转换为单向链表。

## HashMap扩容机制

* **何时触发扩容**

  一般情况下，当元素数量超过阈值时便会触发扩容。每次扩容的容量都是之前容量的2倍。
  注意：
  HashMap的容量必须为2的n次幂，进行扩容时其容量变为不小于指定容量的2的幂数（即初始化容量过程）。
  例如:进行有参初始化时：
  new HashMap<>(5)–>初次put时，容量扩为23 =8，数组长度达到阈值6，扩容为16
  new HashMap<>(7)–>初次put时，容量扩为23 =8，数组长度达到阈值6，扩容为16
  new HashMap<>(13)–>初次put时，容量扩为24 =16，数组长度达到阈值12，扩容为32
  new HashMap<>(19)–>初次put时，容量扩为25 =32，数组长度达到阈值24，扩容为64

  

  为什么**HashMap初始化容量永远都是2的次幂**？

  * HashMap集合初始化容量16（第一次调用put方法时初始化）

  * HashMap集合的容量永远都是2的次幂，假如给定初始化容量为31，它底层也会变成32的容量。

  * 将容量设置为2的次幂作用是：加快哈希计算，减少哈希冲突。

  * 为什么会加快哈希计算？

    首先你要知道，使用二进制运算是最快的。当一个数字是2的次幂时，例如数组的长度是2的次幂：hash & (length-1) 的结果和 hash % length的结果相同。注意：只有是2的次幂时，以上等式才会成立。因为使用 & 运算符，让效率提升，因此建议容量一直是2的次幂。

  * 为什么会减少哈希冲突？

    底层运算是：hash & length - 1，如果length是偶数：length-1后一定是奇数，奇数二进制位最后一位一定是1,1和其他二进制位进行与运算，结果可能是1，也可能是0，这样可以减少哈希冲突，让散列分布更加均匀。如果length是奇数：length-1后一定是偶数，偶数二进制位最后一位一定是0,0和任何数进行与运算，结果一定是0，这样就会导致发生大量的哈希冲突，白白浪费了一半的空间。

* **扩容机制**

  * 创建新数组，需要将老数组的数据挪动到新数组

  * 没有哈希冲突的节点，则直接使用 `e.hash & (newCap - 1)` 计算新数组的索引位置

  * 如果当前节点在链表中，则需要遍历链表，判断每个节点的哈希值与旧容量的关系：

    - 如果 `(e.hash & oldCap) == 0`，该元素保留在原位置。
    - 否则，移动到`原位置+增加的数组大小`的位置。

  * 如果是红黑树，则会调用split()方法，将红黑树切分为两个链表，之后进行扩容操作

    



