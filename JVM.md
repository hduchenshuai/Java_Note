# JVM概述

## 什么是JVM

 JVM 本质上是一个运行在计算机上的程序，他的职责是运行Java字节码文件

![571aa6c49e8f73ae9324db32a89ac10](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409011750655.png)

## JVM的功能

1. **解释和运行**
   * 对字节码文件中的指令实时的解释成机器码让计算机执行
2. **内存管理**
   * 自动为对象、方法等分配内存
   * 自动的垃圾回收机制， 回收不再使用的对象
3. **即时编译（JIT）**
   * 对热点代码进行优化， 提升执行效率
   *  Java需要实时解释，主要是为了支持跨平台特性。

## JVM的种类

![20fb619f56cef127586ec85677c31da](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409011755439.png)

## JVM的组成

![2b13b9a39b9bd1f59f496cd866a2da7](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409011819957.png)

# 字节码文件的组成

**基础信息**：魔数、字节码文件对应的Java版本号； 访问标识(public final等等)； 父类和接口

**常量池**：保存了字符串常量、类或接口名、字段名 主要在字节码指令中使用

* 常量池中的数据都有一个编号，编号从1开始。在字段或者字节码指令中通过编号可以快速的找到对应的数据
* 字节码指令中通过编号引用到常量池的过程称之为**符号引用**

**字段**：当前类或接口声明的字段信息

**方法**：当前类或接口声明的方法信息 ；字节码指令

* 字节码中的方法区域是存放**字节码指令**的核心位置，字节码指令的内容存放在方法的Code属性中

**属性**：类的属性，比如源码的文件名 ；内部类的列表等



**i++ 和 ++i 的区别**

```
int i = 0 ;
i = i++;
最终i的值是多少？

i还是0，i++先把局部变量表中的0复制一个加载到操作数栈，接下来在局部变量表中对i进行+1,最后再将栈中的数（0）取出来覆盖掉局部变量表中i的值，i从1又变成了0；
```

![ea989accd6305bb8889c591dc15e67c](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082037653.png)





# 类的生命周期

**1.加载(Loading)**

类加载器根据类的**全限定名**通过不同的渠道以**二进制流的方式**将字节码信息加载到内存中，存放在方法区和堆上

* 不同渠道包括：本地文件（磁盘上的字节码文件）、程序运行时使用动态代理生成、通过网络传输的类
* 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的**方法区**中；**生成一个InstanceKlass对象，保存类的所有信息**，里边还包含实现特定功能比如多态的信息
* 同时，Java虚拟机还会在**堆**中生成一份与方法区中数据类似的**java.lang.Class对象**；作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）

**2.连接(Linking)**

* **2.1 验证**：是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束，这个阶段一般不需要程序员参与
* **2.2 准备**：为静态变量分配内存并设置初始值
  * byte 0、short 0、int 0、long 0L、double 0.0、boolean false 、char '\u0000'、引用数据类型 null
  * final修饰的**基本数据类型**的静态变量（常量），准备阶段直接会将代码中的值进行赋值

* **2.3 解析**：将常量池中的符号引用替换为指向内存的直接引用
  * 符号引用就是在字节码文件中使用编号来访问常量池中的内容
  * 直接引用不再使用编号，而是使用内存中地址进行访问具体的数据

**3.初始化(Initialization)**

执行**静态代码块中**的代码，并为**静态变量**赋值。执行流程与代码流程一致。

执行字节码文件中clinit部分的字节码指令

* 以下几种方式会导致类的加载并初始化
  * 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化
  * 调用Class.forName(String className)
  * new一个该类的对象时
  * 执行Main方法的当前类

*  clinit指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行（即不存在初始化阶段）：
  * 无静态代码块且无静态变量赋值语句
  * 有静态变量的声明，但是没有赋值语句
  * 静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化

* 存在继承关系的情况：
  * 直接访问父类的静态变量，不会触发子类的初始化
  * 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法

* 其他情况
  * 数组的创建不会导致数组中元素的类进行初始化
  * final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化

**4.使用(Using)**

**5.卸载(Unloading)**

# 类加载器

## 什么是类加载器

类加载器（ClassLoader）是jvm提供给应用程序去实现获取类和接口字节码数据的技术

![b66ce533a4bb7fa7b937ad0b08b4d97](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646670.png)

## 类加载器的分类

 ![4673b82cceb53f43599bb098f6cc0da](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646229.png)

所有**Java中实现的类加载器**都需要继承 ClassLoader这个抽象类，具体继承结构：

![bfcf5a38bb5af5f25008a19e135ddd5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646901.png)

## 双亲委派机制

在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器；如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载；当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，会自顶向下委派子类加载器加载。

![ec3374ca3c63f289e93e49778973986](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646896.png)

* 每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级， 并不是继承关系

  ```java
  private final ClassLoader parent;
  ```

* 应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空
*  启动类加载器使用C++编写，没有上级类加载器



## **双亲委派机制的作用**

1. **保证类加载的安全性**

   通过双亲委派机制让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库，比如自定义String类，启动类加载器在加载过程中会先加载jdk自带的文件（rt.jar中java.lang.String.class），报错说没main方法，这样确保核心类库的完整性和安全性。

2. **避免重复加载**

   双亲委派机制可以避免同一个类被 多次加载，上层的类加载器如果加载过类，就会直接返回该类，避免重复加载。



## 打破双亲委派机制

### **1.自定义类加载器并且重写 loadClass方法**

ClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于**loadClass**方法中

![4114dd4db8c1feafd4ddbcd529028b5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231645575.png)

故重写**loadClass**方法，去除双亲委派机制核心代码，自然就打破了双亲委派机制；

正确的去实现一个自定义类加载器的方式是重写**findClass**方法，这样不会破坏双亲委派机制

注意：

* 自定义类加载器父类是AppClassLoader
  * ClassLoader类中提供了构造方法设置parent的内容；这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的是AppClassLoader

* 两个自定义类加载器加载相同限定名的类，会不会冲突？
  * 不会冲突，在同一个Java虚拟机中，只有**相同类加载器+相同的类限定名**才 会被认为是同一个类

### **2.线程上下文类加载器**

JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动； DriverManager类位于rt.jar包中，由启动类加载器加载；在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动，SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制

**SPI：**![f6acc4cc6095952d41706df6ffd2cb1](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231643659.png)

![a3cce3703b1a336b85585b9748317b2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231643240.png)

注意：另一种看法，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制，并没有打破。真正意义上的打破双亲委派只有重写掉loadclass方法中关于双亲委派的代码

### **3.OSGi模块化**

OSGi模块化框架，它存在同级之间的类加载器的委托加载

# 运行时数据区

## 程序计数器

程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址

在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址，在代码执行过程中，程序计数器会记录**下一行字节码指令的地址**。执行完当前指令之后，虚拟机的执行引擎根据 程序计数器执行下一行指令

程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑

在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行



**程序计数器在运行中会出现内存溢出吗？**

不会。内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存 大小超过了虚拟机能提供的内存上限。因为**每个线程只存储一个固定长度的内存地址**，程序计数器是不会发生内存 溢出的，程序员无需对程序计数器做任何处理

## 栈

**Java虚拟机栈**存储了Java方法调用时的栈帧

**本地方法栈**存储的是native本地方法的栈帧

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了**同一个栈空间**



### **Java虚拟机栈**

* Java虚拟机栈采用栈的数据结构来管理方法调用中的基本数据，先进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存
* **Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行**。由于方法可能会在不同线 程中执行，每个线程都会包含一个自己的虚拟机栈
* Java虚拟机栈 中 **栈帧** 的组成：**局部变量表**、**操作数栈**、**帧数据**

#### 局部变量表

* 局部变量表的作用是在方法执行过程中存放所有的局部变量，包括**实例方法的this对象**，**方法的参数**，**方法体中声明的局部变量**

* 栈帧中的局部变量表是一个**数组**，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个

* **实例方法**中的序号为0的位置（0号槽位）存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址

* 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致

* 为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用

  ![cb291d57222464e062b8185e9cc10c0](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241521261.png)

#### 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来**存放中间数据的一块区域**；他是一种**栈式的数据结构**

在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小

#### 帧数据

帧数据主要包含动态链接、方法出口、异常表的引用：

* 动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系
* 方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的 下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址
* 异常表存放的是代码中异常的处理信息，包含了**异常捕获的生效范围**以及异常发生后**跳转到的字节码指令位置**

### 栈内存溢出

Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出：StackOverflowError

如果不指定栈的大小，JVM 将创建一个**具有默认大小的栈**。大小取决于操作系统和计算机的体系结构:

linux x86(64位)：1MB

Windows(64位)：1MB

要修改Java虚拟机栈的大小，可以使用虚拟机参数 `-Xss栈大小`，单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

HotSpot JVM对栈大小的最大值和最小值有要求, Windows（64位）下的JDK8测试**最小值为180k**，**最大值为1024m**

局部变量过多、操作数栈深度过大也会影响栈内存的大小

一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数 可以手动指定为-Xss256k节省内存

### 本地方法栈

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了**同一个栈空间**。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来

## 堆

堆空间有三个需要关注的值，**used** **total** **max**

used指的是当前**已使用**的堆内存，total是java虚拟机**已经分配**的可用堆内存，max是java虚拟机可以分配的**最大**堆内存

随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆

如果堆内存不足，java虚拟机就会不断的分配内存，total值会变大。total最多只能与max相等



**是不是当used = max = total的时候，堆内存就溢出了呢？**

不是，堆内存溢出的判断条件比较复杂，在《垃圾回收器》中会详细介绍



**堆设置大小**

如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。**在实际应用中一般都需要设置 total和max的值**

要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)

语法：-Xmx值 -Xms值

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

限制：Xmx必须大于 2 MB，Xms必须大于1 MB

Java服务端程序开发时，**建议将-Xmx和-Xms设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而无 需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。

-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案

## 方法区

1.方法区是《Java虚拟机规范》中设计的**虚拟概念**，每款Java虚拟机在实现上都各不相同，Hotspot设计如下：

* **JDK7及之前**的版本将方法区存放在**堆区域中的永久代空间**，故会存在内存溢出的可能，堆的大小由虚拟机参数

  -XX:MaxPermSize=值来控制

* **JDK8及之后**的版本将方法区存放在**元空间中**，元空间位于操作系统维护的**直接内存**中，默认情况下只要不超过操作系统承受的上限，可以一直分配，可以使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制

![6e9035a9cde1e9a4777949e31cdce62](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241725830.png)



2.方法区是存放基础信息的位置，线程共享，主要包含三部分内容：**类的元信息、运行时常量池、字符串常量池**：

* 类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成

  ![efd78585386bf13040c9f5dfa2664b1](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241715439.png)

* 运行时常量池中存放的是字节码中的常量池内容

  字节码文件中通过编号查表的方式找到常量，这种常量池称为**静态常量池**。

  当常量池加载到内存中之后，可以通 过内存地址快速的定位到常量池中的内容，这种常量池称为**运行时常量池**![345cf033995c07589b3ff2a696824fb](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241721328.png)

* 字符串常量池(StringTable)存储在代码中定义的常量字符串内容，比如“123”

  * 字符串常量池和运行时常量池有什么关系？

    jdk8：运行时常量池在方法区，即元空间，即操作系统维护的直接内存中
    
    ​			字符串常量池在堆中
    
    ![99b7353760da55ac09d4863989770b2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241733155.png)

3.静态变量的存储

JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代：

![c629113d9cfc30a44a08b9d0164072b](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241739486.png)

JDK7及之后的版本中，**静态变量是存放在堆中的Class对象中**，脱离了永久代：

![6cb67350ebe3725ac1dc9b205017e05](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241739608.png)

# 垃圾回收

在C/C++这类没有自动垃圾回收机制的语言中，一个对象如果不再使用，需要手动释放，否则就会出现**内存泄漏**。我们称这种释放对象的过程为**垃圾回收**，而需要程序员编写代码进行回收的方式为**手动回收**。

**内存泄漏**：指的是不再使用的对象在系统中未被回收，内存泄漏的积累可能会导致内存溢出

Java中为了简化对象的释放，引入了自动的垃圾回收（Garbage Collection简称GC）机制。通过垃圾回收器来对不再使用的对象完成自动的回收，垃圾回收器主要负责对**堆**上的内存进行回收。

**自动垃圾回收与手动回收对比：**

自动：优点：降低程序员实现难度、降低对象回收bug的可能性； 缺点：程序员无法控制内存回收的**及时性**

手动：优点：及时性高   缺点：编写不当容易出现悬空指针、重复释放、内存泄漏等问题

**线程不共享的部分（栈和程序计数器），都是伴随着线程的创建而创建，线程的销毁而销毁。**而方法的栈帧在执行完方法之后就会 自动弹出栈并释放掉对应的内存



如果需要手动触发垃圾回收，可以调用System.gc()方法

调用System.gc()方法并**不一定会立即回收垃圾**，仅仅是向Java虚拟机发送一个垃圾回收的请求，具体是否需要执行垃圾回收Java虚拟机会自行判断。

## 方法区的回收

方法区中能回收的内容主要就是**不再使用的类**

判定一个类可以被卸载，需要**同时满足**下面三个条件： 

1、此类所有实例对象都已经被回收，在堆中不存在任何该类的实例对象以及子类对象。 

2、加载该类的类加载器已经被回收。 

3、该类对应的 java.lang.Class 对象没有在任何地方被引用。

注：我们自己写的类由应用程序类加载器加载，应用程序类加载器一般不会被回收，故**开发中此类场景一般很少出现**，主要在如 OSGi、JSP 的热部署等应用场景中，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器，重新创建类加载器，重新加载jsp文件





## **堆回收**

### 如何判断堆上的对象可以回收？

Java中的对象是否能被回收，是根据对象**是否被引用**来决定的。如果对象被引用了，说明该对象还在使用，不允许被回收。

只有无法通过引用获取到对象时，该对象才能被回收。 

下图**循环引用**示例中A的实例对象要想回收，就有两个引用要去除：

![ea41519d124ce06eff8b56fda83a158](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408282018740.png)

如果在main方法中最后执行 a1 = null ，b1 = null，是否能回收A和B对象呢？

可以回收，方法中已经没有办法使用引用去访问A和B对象了

![e2d255ef14c19e8ce7b650bd4c53ee1](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408282020970.png)

### 如何判断堆上的对象没有被引用？

常见的有两种判断方法：**引用计数法 **和 **可达性分析法**

* **引用计数法**（java未采用）
  * 引用计数法会为每个对象维护一个引用计数器，当对象被引用时加1，取消引用时减1。
  * 优点：实现简单
  * 缺点：
    * 每次引用和取消引用都需要维护计数器，对系统性能会有一定的影响
    * 存在循环引用问题时会出现对象无法回收的问题

![338d458d87569b8dbfba0f0db9deda9](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408282027753.png)



* **可达性分析算法**

  Java使用的是可达性分析算法来判断对象是否可以被回收。

  可达性分析将对象分为两类：**垃圾回收的** **根对象（GC  Root）**和 **普通对象**，对象与对象之间存在引用关系。、

  下图中A到B再到C和D，形成了一个**引用链**，可达性分析算法指的是如果从某个到GC Root对象是可达的，对象就 不可被回收。

  ![80bb6722eb521ffb2d3438ee958c5bc](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408282033319.png)

​	**哪些对象被称之为GC Root对象呢？**

* 线程Thread对象
* 系统类加载器（又称应用程序类加载器）加载的java.lang.Class对象
* 监视器对象，用来保存同步锁synchronized关键字持有的对象
* 本地方法调用时使用的全局对象



​	**可达性分析法解决了循环引用的问题：**

![518df4d8b4bdfbf0771286f32ba2e0f](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408282054245.png)

### 对象引用

可达性算法中描述的对象引用，一般指的是强引用，即是GCRoot对象对普通对象有引用关系，只要这层关系存在， 普通对象就不会被回收。

除了强引用之外，Java中还设计了几种其他引用方式：

* 软引用
* 弱引用
* 虚引用
* 终结器引用



#### 软引用

软引用相对于强引用是一种比较弱的引用关系，如果一个对象**只有**软引用关联到它，**当程序内存不足时，就会将软引用中的数据进行回收。**

在JDK 1.2版之后提供了SoftReference类来实现软引用，软引用常用于缓存中。

![649341eb067aca131ba490ab065a7e5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082037577.png)

**软引用的执行过程**如下： 

1.将对象使用软引用包装起来，new SoftReference<对象类型>(对象)。

2.内存不足时，虚拟机尝试进行垃圾回收。 

3.如果垃圾回收仍不能解决内存不足的问题，回收软引用中的对象。 

4.如果依然内存不足，抛出OutOfMemory异常。



软引用中的对象如果在内存不足时回收，SoftReference对象本身也需要被回收。

**如何知道哪些SoftReference对 象需要回收呢？**

SoftReference提供了一套队列机制： 

1、软引用创建时，通过构造器传入引用队列 

2、在软引用中包含的对象被回收时，该软引用对象会被放入引用队列 

3、通过代码遍历引用队列，将SoftReference的强引用删除

#### 弱引用

弱引用的整体机制和软引用基本一致，区别在于弱引用包含的对象在垃圾回收时，**不管内存够不够都会直接被回收**。 

在JDK 1.2版之后提供了WeakReference类来实现弱引用，弱引用主要在ThreadLocal中使用。 

弱引用对象本身也可以使用引用队列进行回收

#### 虚引用

虚引用也叫幽灵引用/幻影引用，不能通过虚引用对象获取到包含的对象。虚引用唯一的用途是**当对象被垃圾回收器回收时可以接收到对应的通知**。Java中使用PhantomReference实现了虚引用，直接内存中为了及时知道 直接内存对象不再使用，从而回收内存，使用了虚引用来实现。

#### 终结器引用

终结器引用指的是在对象需要被回收时，终结器引用会关联对象并放置在Finalizer类中的引用队列中，在稍后 由一条由FinalizerThread线程从队列中获取对象，然后执行对象的finalize方法，在对象第二次被回收时，该对象才真正的被回收。在这个过程中可以在finalize方法中再将自身对象使用强引用关联上，使其不会回收进行自救，但是不建议这样做。

总结：**续命用，遇到第一次回收，开一个线程去执行对象的finalize方法，遇到第二次才会回收**

注意：对象的finalize方法什么时候执行，甚至执不执行均由回收器决定，程序员无法控制，故在finalize方法中做一些收尾动作是不推荐的，实际开发不会这么做。

### 垃圾回收算法

#### 核心思想

简单来说，垃圾回收要做的有两件事： 

1、找到内存中存活的对象 

2、释放不再存活对象的内存，使得程序能再次利用这部分空间



#### 垃圾回收算法的分类

* 标记-清除算法

* 复制算法

* 标记-整理算法

* 分代GC



#### 垃圾回收算法的评价标准

Java垃圾回收过程会通过单独的GC线程来完成，但是不管使用哪一种GC算法，都会有部分阶段需要停止所 有的用户线程。这个过程被称之为Stop The World简称STW，如果STW时间过长则会影响用户的使用。

所以判断GC算法是否优秀，可以从三个方面来考虑：

**1、吞吐量**

吞吐量指的是 CPU 用于执行用户代码的时间与 CPU 总执行时间的比值，即吞吐量 = 执行用户代码时间 / （执行用户代码时间 + GC时间）。吞吐量数值越高，垃圾回收的效率就越高。

比如：虚拟机总共运行了 100 分钟，其中GC花掉 1 分钟，那么吞吐量就是 99%

**2、最大暂停时间**

最大暂停时间指的是所有在垃圾回收过程中的STW时间最大值。最大暂停时间越短，用户使用系统时 受到的影响就越短。

**3、堆使用效率** 

不同垃圾回收算法，对堆内存的使用方式是不同的。比如标记清除算法，可以使用完整的堆内存。而复制算法会将堆内存一分为二，每次只能使用一半内存。从堆使用效率上来说，标记清除算法要优于复制算法。

上述三种评价标准：堆使用效率、吞吐量，以及最大暂停时间**不可兼得**。 一般来说，堆内存越大，最大暂停时间就越长。想要减少最大暂停时间，就会降低吞吐量。 不同的垃圾回收算法，适用于不同的场景

#### 标记清除算法

标记清除算法的核心思想分为两个阶段： 

1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。 

2.清除阶段，从内存中删除没有被标记也就是非存活对象



优点：

实现简单，只需要在第一阶段给每个对象维护标志位，第二阶段删除对象即可。 

缺点：

1.碎片化问题： 由于内存是连续的，所以在对象被删除之后，内存中会出现很多细小的可用内存单元。如果我们需要的是一 个比较大的空间，很有可能这些内存单元的大小过小无法进行分配。

2.分配速度慢：由于内存碎片的存在，需要维护一个空闲链表，极有可能发生每次需要遍历到链表的最后才能获得合适的内存空间

#### 复制算法

完整的复制算法实现： 

1.将堆内存分割成两块：From空间 和 To空间，对象分配阶段，创建对象，只能使用其中From空间。

2.GC阶段开始，将GC Root搬运到To空间 

3.将GC Root关联的对象，搬运到To空间

4.清理From空间，并把名称互换



优点：

1.吞吐量高：复制算法只需要遍历一次存活对象 复制到To空间即可，比标记-整理 算法少了一次遍历的过程，因而性能较好，但是不如标记-清除算法， 因为标记清除算法不需要进行对象 的移动

2.不会发生碎片化：复制算法在复制之后就会将对象按顺序放入To空间中，所以对象以外的区域都是可用空间，不存在碎片化内存空间。



缺点：

内存使用效率低：每次只能让一半的内存空间来为创 建对象使用



#### 标记整理算法

标记整理算法也叫标记压缩算法，是对标记清除算法中容易产生内存碎片问题的一种解决方案。 

核心思想分为两个阶段： 

1.标记阶段，将所有存活的对象进行标记。Java中使用可达性分析算法，从GC Root开始通过引用链遍历出所有存活对象。 

2.整理阶段，将存活对象移动到堆的一端。清理掉非存活对象的内存空间。



优点：

1.内存使用效率高：整个堆内存都可以使用，不会像复制算法只能使用半个堆内存

2.不会发生碎片化：在整理阶段可以将对象往内存的一侧进行移动，剩下的空间都是可以分配对象的有效空间

缺点：

整理阶段的效率不高：整理算法有很多种，比如Lisp2整理算法需要对整个堆中的对象搜索3次，整体性能不佳。可以通过TwoFinger、表格算法、ImmixGC等高效的整理算法优化此阶段的性能



#### 分代GC

现代优秀的垃圾回收算法，会将上述描述的垃圾回收算法组合进行使用，其中应用最广的就是分代垃圾回收算法

分代垃圾回收将整个内存区域划分为**年轻代和老年代**，年轻代被细分为**伊甸园区**和**幸存区From**和**幸存区To**

* 分代回收时，创建出来的对象，首先会被放入Eden伊甸园区
* 伊甸园放不下时会第一次触发年轻代的GC，称为 Minor GC或者Young GC，将存活的对象复制到To区域，其余被回收，同时将To和From区交换，存活的对象年龄加1。注意：每次Minor GC中都会为对象记录他的年龄，**初始值为0，每次GC完加1**
* 当伊甸园再次放不下时，再次触发Minor GC，将伊甸园区和From区的对象进行回收，将幸存下来的对象复制到To区，同时将To和From区交换
* 如果对象的年龄达到阈值（最大15，默认值和垃圾回收器有关），对象就会被晋升至老年代。
* 当老年代中空间不足，无法放入新的对象时，**先尝试minor gc**，如果还是不足，就会触发Full GC，Full GC会对整个堆进行垃圾回收
* 如果Full GC依然无法回收掉老年代的对象，那么当对象继续放入老年代时，就会抛出Out Of Memory异常。

注意：Minor GC和Full GC都会引发STW，只不过Full GC的STW时间较长



为什么分代GC算法要把堆分成年轻代和老年代？

系统中的大部分对象，都是创建出来之后很快就不再使用可以被回收，比如用户获取订单数据，订单数据返回给用户之后就可以释放了。 老年代中会存放长期存活的对象，比如Spring的大部分bean对象，在程序启动之后就不会被回收了。 

在虚拟机的默认设置中，新生代大小要远小于老年代的大小。

具体原因：

1、可以通过调整年轻代和老年代的比例来适应不同类型的应用程序，提高内存的利用率和性能。 

2、新生代和老年代使用不同的垃圾回收算法，**新生代一般选择复制算法**，老年代可以选择**标记-清除和标记-整理** 算法，由程序员来选择灵活度较高。 

3、分代的设计中 允许只回收新生代（minor gc），如果能满足对象分配的要求就不需要对整个堆进行回收(full  gc),STW时间就会减少。



### 垃圾回收器

垃圾回收器是垃圾回收算法的具体实现。 

由于垃圾回收器分为年轻代和老年代，**除了G1之外**其他垃圾回收器必须成对组合进行使用。 具体的关系图如下：

![b06a1bd96fc5c23fae5d32f85232115](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082037800.png)

#### 年轻代-Serial垃圾回收器

![12ac50fca3d455fc89a49c9bfaef75f](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036269.png)

#### 老年代-SerialOld垃圾回收器

![aabcdb203a1bb8e51860d02dfb6cf50](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036910.png)



#### 年轻代-ParNew垃圾回收器

![ee8efedc62afcbb2f8c0f390bf00ba0](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036797.png)

#### 老年代-CMS垃圾回收器

![d06acc5a57ba006c51604647fa5abcf](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036221.png)

CMS(Concurrent Mark Sweep)执行步骤： 

1. 初始标记，用极短的时间标记出GCRoots能直接关联到的对象。
2. 并发标记,   标记所有的对象，用户线程不需要暂停。 
3. 重新标记，由于并发标记阶段有些对象会发生了变化，存在错标、漏标等情况，需要重新标记。 
4. 并发清理，清理死亡的对象，用户线程不需要暂停

优点：

1、CMS垃圾回收器关注的是系统的暂停时间， 允许用户线程和垃圾回收线程在某些步骤中同时执行，**减少了用户线程的等待时间**，系统由于垃圾回收出现的停顿时间较短，用户体验好

缺点： 

1、CMS使用了**标记-清除算法**，在垃圾收集结束之后会出现大量的内存碎片，CMS会在Full GC时进行碎片的整理。 这样会导致用户线程暂停

2、无法处理在并发清理过程中产生的“**浮动垃圾**”，不能做到完全的垃圾回收。

3、如果老年代内存不足无法分配对象，CMS就会退化成Serial Old单线程回收老年代

4、存在线程资源争抢问题，由于CPU的核心数有限，就会影响用户线程执行的性能



适用场景：

大型的互联网系统中用户请求数 据量大、频率高的场景 比如订单接口、商品接口等



#### 年轻代-Parallel Scavenge垃圾回收器

![ea6a6bbffb8f714f850326a1fcfe0b0](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036543.png)

#### 老年代-Parallel Old垃圾回收器

![c5f0b083b389e4ad953d362762430fd](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082036752.png)

#### G1垃圾回收器（jdk9+默认）

Parallel Scavenge关注吞吐量，允许用户设置最大暂停时间 ，但是会减少年轻代可用空间的大小。 CMS关注暂停时间，但是吞吐量方面会下降

而G1设计目标就是将上述两种垃圾回收器的**优点**融合： 

1.支持巨大的堆空间回收，并有较高的吞吐量

2.支持多CPU并行垃圾回收

3.允许用户设置最大暂停时间

4.不会产生内存碎片（复制算法）



G1的整个堆会被划分成多个大小相等的区域，称之为区Region，区域不要求是连续的。分为Eden、Survivor、 Old区。

Region的大小通过堆空间大小/2048计算得到，也可以通过参数-XX:G1HeapRegionSize=32m指定，Region size必须是2的指数幂，取值范围从1M到32M。



G1垃圾回收有两种方式：

 1、年轻代回收（Young GC）

* Young GC，回收Eden区和Survivor区中不用的对象。会导致STW，G1中可以通过参数-XX:MaxGCPauseMillis=n（默认200） 设置每次垃圾回收时的最大暂停时间毫秒数，G1垃圾回收器会尽可能地保证暂停时间

 2、混合回收（Mixed GC）

* 混合回收分为：初始标记、并发标记、最终标记、并发清理

* G1对老年代的清理会选择存活度最低的区域来进行回收，这样可以保证回收效率最高，这也是G1（Garbage  first）名称的由来
* 最后清理阶段使用**复制算法**，不会产生内存碎片

注意：如果清理过程中发现没有足够的空Region存放转移的对象，会出现**Full GC**，由单线程执行标记-整理算法， 此时会导致用户线程的暂停。

​			所以尽量保证应该用的堆内存有一定多余的空间

![6b8fb5768a3308e6514a771338f5dd8](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202409082035275.png)



**G1垃圾回收器 –执行流程** 

1、新创建的对象会存放在Eden区。当G1判断年轻代区不足（max默认60%，即eden+survivor占了总堆60%），无法分配对象时需要回收会执行 Young GC。 

2、标记出Eden和Survivor区域中的存活对象， 

3、根据配置的最大暂停时间去判断这次回收要处理哪些区域， 再将这些区域中的存活对象复制到一个新的Survivor区中（年龄+1），清空这些区域

解释：G1在进行Young GC的过程中会去记录每次垃圾回收时每个Eden区和Survivor区的平均耗时，以作为下次回收时的 参考依据。这样就可以根据配置的最大暂停时间计算出本次回收时最多能回收多少个Region区域了。 比如 -XX:MaxGCPauseMillis=n（默认200），每个Region回收耗时40ms，那么这次回收最多只能回收4个Region。

4、后续Young GC时与之前相同，只不过Survivor区中存活对象会被搬运到另一个Survivor区。 

5、当某个存活对象的年龄到达阈值（默认15），将被放入老年代

6、部分对象如果大小超过Region的一半，会直接放入老年代，这类老年代被称为Humongous区。比如堆内存是 4G，每个Region是2M，只要一个大对象超过了1M就被放入Humongous区，如果对象过大会横跨多个Region

7、多次回收之后，会出现很多Old老年代区，此时总堆占有率达到阈值时 （-XX:InitiatingHeapOccupancyPercent默认45%）会触发混合回收Mixed GC。回收所有年轻代 和 部分老年代的对象 以及 大对象区。采用复制算法来完成。回收后，年轻代存活的放到新的幸存区，老年代存活的放到新的老年代





# 内存泄漏问题实战

## 内存溢出和内存泄漏

内存泄漏（memory leak）：在Java中如果不再使用一个对象，但是该对象依然在GC ROOT的引用链上， **这个对象就不会被垃圾回收器回收，这种情况就称之为内存泄漏。**

少量的内存泄漏可以容忍，但是如果发生持续的内存泄漏，就像滚雪球雪球越滚越大，不管有多大的内存迟早会被消耗完，最终导致的结果就是**内存溢出**。

**但是产生内存溢出并不是只有内存泄漏这一种原因**。

```
百度2面：内存溢出和内存泄漏区别？
```

```java
* 内存泄漏 (Memory Leak)
定义：内存泄漏是指程序在运行过程中，动态分配的内存不再被使用，但程序未能释放这些内存，导致可用内存逐渐减少。
原因：常见原因包括：
对象仍被引用，无法被垃圾回收器回收。
使用集合（如 List、Map）存储对象后，未能清理不再需要的引用。
事件监听器未解除注册，导致对象无法被回收。
后果：随着时间的推移，内存泄漏会导致程序的可用内存逐渐减少，最终可能导致性能下降，甚至崩溃。

* 内存溢出 (Out of Memory)
定义：内存溢出是指程序请求的内存超过了可用内存，导致程序无法继续分配内存。
原因：常见原因包括：
程序中存在大量对象的创建，超出了 JVM 的内存限制。
内存泄漏导致可用内存减少，最终导致溢出。
不合理的内存配置，如设置的堆内存过小。
后果：内存溢出通常会导致程序抛出 OutOfMemoryError 异常，程序无法继续运行。

区别
内存泄漏 是一种状态，指的是内存未被正确释放；而 内存溢出 是一种错误，指的是程序尝试使用超过可用内存的情况。
内存泄漏可能导致内存溢出，但并非所有内存泄漏都会立即导致内存溢出。
```

# JVM参数

 -Xmx：最大堆内存

 –Xms：初始堆内存

 -XX:MaxMetaspaceSize：最大元空间大小

 –XX:MetaspaceSize：是到达这个值之后会触发FULL GC

-Xss ：虚拟机栈大小



以下参数不建议手动设置

-Xmn：年轻代的大小，默认值为整个堆的1/3，可以根据峰值流量计算最大的年轻代大小，尽量让对象只存放在年 轻代，不进入老年代。但是实际的场景中，接口的响应时间、创建对象的大小、程序内部还会有一些定时任务等不 确定因素都会导致这个值的大小并不能仅凭计算得出，如果设置该值要进行大量的测试。G1垃圾回收器尽量不要设 置该值，G1会动态调整年轻代的大小

‐XX:SurvivorRatio 伊甸园区和幸存者区的大小比例，默认值为8。

‐XX:MaxTenuringThreshold 最大晋升阈值，年龄大于此值之后，会进入老年代。另外JVM有动态年龄判断机制：将年龄从小到大的对象占据的空间加起来，如果大于survivor区域的50%，然后把等于或大于该年龄的对象， 放入到老年代
