# 类的生命周期

**1.加载(Loading)**

类加载器根据类的全限定名通过不同的渠道以二进制流的方式将字节码信息加载到内存中，存放在方法区和堆上

* 不同渠道包括：本地文件（磁盘上的字节码文件）、程序运行时使用动态代理生成、通过网络传输的类
* 类加载器在加载完类之后，Java虚拟机会将字节码中的信息保存到内存的方法区中；生成一个InstanceKlass对象，保存类的所有信息，里边还包含实现特定功能比如多态的信息
* 同时，Java虚拟机还会在堆中生成一份与方法区中数据类似的java.lang.Class对象；作用是在Java代码中去获取类的信息以及存储静态字段的数据（JDK8及之后）

**2.连接(Linking)**

* **2.1 验证**：是检测Java字节码文件是否遵守了《Java虚拟机规范》中的约束，这个阶段一般不需要程序员参与
* **2.2 准备**：为静态变量分配内存并设置初始值
  * byte 0、short 0、int 0、long 0L、double 0.0、boolean false 、char '\u0000'、引用数据类型 null
  * final修饰的基本数据类型的静态变量，准备阶段直接会将代码中的值进行赋值

* **2.3 解析**：将常量池中的符号引用替换为指向内存的直接引用
  * 符号引用就是在字节码文件中使用编号来访问常量池中的内容
  * 直接引用不再使用编号，而是使用内存中地址进行访问具体的数据

**3.初始化(Initialization)**

执行**静态代码块中**的代码，并为**静态变量**赋值。执行流程与代码流程一致。

执行字节码文件中clinit部分的字节码指令

* 以下几种方式会导致类的加载并初始化
  * 访问一个类的静态变量或者静态方法，注意变量是final修饰的并且等号右边是常量不会触发初始化
  * 调用Class.forName(String className)
  * new一个该类的对象时
  * 执行Main方法的当前类

*  clinit指令在特定情况下不会出现，比如：如下几种情况是不会进行初始化指令执行（即不存在初始化阶段）：
  * 无静态代码块且无静态变量赋值语句
  * .有静态变量的声明，但是没有赋值语句
  * 静态变量的定义使用final关键字，这类变量会在准备阶段直接进行初始化

* 存在继承关系的情况：
  * 直接访问父类的静态变量，不会触发子类的初始化
  * 子类的初始化clinit调用之前，会先调用父类的clinit初始化方法

* 其他情况
  * 数组的创建不会导致数组中元素的类进行初始化
  * final修饰的变量如果赋值的内容需要执行指令才能得出结果，会执行clinit方法进行初始化

**4.使用(Using)**

**5.卸载(Unloading)**

# 类加载器

## 什么是类加载器

类加载器（ClassLoader）是jvm提供给应用程序去实现获取类和接口字节码数据的技术

![b66ce533a4bb7fa7b937ad0b08b4d97](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646670.png)

## 类加载器的分类

 ![4673b82cceb53f43599bb098f6cc0da](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646229.png)

所有Java中实现的类加载器都需要继承 ClassLoader这个抽象类，具体继承结构：

![bfcf5a38bb5af5f25008a19e135ddd5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646901.png)

## 双亲委派机制

在类加载的过程中，每个类加载器都会先检查是否已经加载了该类，如果已经加载则直接返回，否则会将加载请求委派给父类加载器；如果所有的父类加载器都无法加载该类，则由当前类加载器自己尝试加载；当父类加载器反馈自己无法完成这个加载请求（它的搜索范围没有找到所需的类）时，会自顶向下委派子类加载器加载。

![ec3374ca3c63f289e93e49778973986](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231646896.png)

* 每个Java实现的类加载器中保存了一个成员变量叫“父”（Parent）类加载器，可以理解为它的上级， 并不是继承关系

  ```java
  private final ClassLoader parent;
  ```

* 应用程序类加载器的parent父类加载器是扩展类加载器，而扩展类加载器的parent是空
*  启动类加载器使用C++编写，没有上级类加载器



## **双亲委派机制的作用**

1. 保证类加载的安全性

   通过双亲委派机制让顶层的类加载器去加载核心类，避免恶意代码替换JDK中的核心类库，比如自定义String类，启动类加载器在加载过程中会先加载jdk自带的文件（rt.jar中java.lang.String.class），报错说没main方法，这样确保核心类库的完整性和安全性。

2. 避免重复加载

   双亲委派机制可以避免同一个类被 多次加载，上层的类加载器如果加载过类，就会直接返回该类，避免重复加载。



## 打破双亲委派机制

### **1.自定义类加载器并且重写 loadClass方法**

ClassLoader中包含了4个核心方法，双亲委派机制的核心代码就位于**loadClass**方法中

![4114dd4db8c1feafd4ddbcd529028b5](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231645575.png)

故重写loadClass方法，去除双亲委派机制核心代码，自然就打破了双亲委派机制；

正确的去实现一个自定义类加载器的方式是重写findClass方法，这样不会破坏双亲委派机制

注意：

* 自定义类加载器父类是AppClassLoader
  * ClassLoader类中提供了构造方法设置parent的内容；这个构造方法由另外一个构造方法调用，其中父类加载器由getSystemClassLoader方法设置，该方法返回的 是AppClassLoader

* 两个自定义类加载器加载相同限定名的类，会不会冲突？
  * 不会冲突，在同一个Java虚拟机中，只有**相同类加载器+相同的类限定名**才 会被认为是同一个类

### **2.线程上下文类加载器**

JDBC中使用了DriverManager来管理项目中引入的不同数据库的驱动，比如mysql驱动、oracle驱动； DriverManager类位于rt.jar包中，由启动类加载器加载；在初始化DriverManager时，通过SPI机制加载jar包中的myql驱动，SPI中利用了线程上下文类加载器（应用程序类加载器）去加载类并创建对象，这种由启动类加载器加载的类，委派应用程序类加载器去加载类的方式，打破了双亲委派机制

**SPI：**![f6acc4cc6095952d41706df6ffd2cb1](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231643659.png)

![a3cce3703b1a336b85585b9748317b2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408231643240.png)

注意：另一种看法，JDBC只是在DriverManager加载完之后，通过初始化阶段触发了驱动类的加载，类的加载依然遵循双亲委派机制，并没有打破。真正意义上的打破双亲委派只有重写掉loadclass方法中关于双亲委派的代码

### **3.OSGi模块化**

OSGi模块化框架，它存在同级之间的类加载器的委托加载

# 运行时数据区

## 程序计数器

程序计数器（Program Counter Register）也叫PC寄存器，每个线程会通过程序计数器记录当前要执行的的字节码指令的地址

在加载阶段，虚拟机将字节码文件中的指令读取到内存之后，会将原文件中的偏移量转换成内存地址。每一条字节码指令都会拥有一个内存地址，在代码执行过程中，程序计数器会记录**下一行字节码指令的地址**。执行完当前指令之后，虚拟机的执行引擎根据 程序计数器执行下一行指令

程序计数器可以控制程序指令的进行，实现分支、跳转、异常等逻辑

在多线程执行情况下，Java虚拟机需要通过程序计数器记录CPU切换前解释执行到那一句指令并继续解释运行



**程序计数器在运行中会出现内存溢出吗？**

不会。内存溢出指的是程序在使用某一块内存区域时，存放的数据需要占用的内存 大小超过了虚拟机能提供的内存上限。因为每个线程只存储一个固定长度的内存地址，程序计数器是不会发生内存 溢出的，程序员无需对程序计数器做任何处理

## 栈

**Java虚拟机栈**存储了Java方法调用时的栈帧

**本地方法栈**存储的是native本地方法的栈帧

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了**同一个栈空间**



### **Java虚拟机栈**

* Java虚拟机栈（Java Virtual Machine Stack）采用栈的数据结构来管理方法调用中的基本数据，先 进后出（First In Last Out）,每一个方法的调用使用一个栈帧（Stack Frame）来保存
* **Java虚拟机栈随着线程的创建而创建，而回收则会在线程的销毁时进行**。由于方法可能会在不同线 程中执行，每个线程都会包含一个自己的虚拟机栈
* Java虚拟机栈 中 **栈帧** 的组成：**局部变量表**、**操作数栈**、**帧数据**

#### 局部变量表

* 局部变量表的作用是在方法执行过程中存放所有的局部变量，包括**实例方法的this对象**，**方法的参数**，**方法体中声明的局部变量**

* 栈帧中的局部变量表是一个**数组**，数组中每一个位置称之为槽(slot) ，long和double类型占用两个槽，其他类型占用一个

* **实例方法**中的序号为0的位置（0号槽位）存放的是this，指的是当前调用方法的对象，运行时会在内存中存放实例对象的地址

* 方法参数也会保存在局部变量表中，其顺序与方法中参数定义的顺序一致

* 为了节省空间，局部变量表中的槽是可以复用的，一旦某个局部变量不再生效，当前槽就可以再次被使用

  ![cb291d57222464e062b8185e9cc10c0](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241521261.png)

#### 操作数栈

操作数栈是栈帧中虚拟机在执行指令过程中用来**存放中间数据的一块区域**；他是一种**栈式的数据结构**

在**编译期**就可以确定操作数栈的最大深度，从而在执行时正确的分配内存大小

#### 帧数据

帧数据主要包含动态链接、方法出口、异常表的引用：

* 动态链接：当前类的字节码指令引用了其他类的属性或者方法时，需要将符号引用（编号）转换成对应的运行时常量池中的内存地址。动态链接就保存了编号到运行时常量池的内存地址的映射关系
* 方法出口指的是方法在正确或者异常结束时，当前栈帧会被弹出，同时程序计数器应该指向上一个栈帧中的 下一条指令的地址。所以在当前栈帧中，需要存储此方法出口的地址
* 异常表存放的是代码中异常的处理信息，包含了**异常捕获的生效范围**以及异常发生后**跳转到的字节码指令位置**

#### 栈内存溢出

Java虚拟机栈如果栈帧过多，占用内存超过栈内存可以分配的最大大小就会出现内存溢出：StackOverflowError

如果不指定栈的大小，JVM 将创建一个**具有默认大小的栈**。大小取决于操作系统和计算机的体系结构:

linux x86(64位)：1MB

Windows(64位)：1MB

要修改Java虚拟机栈的大小，可以使用虚拟机参数 `-Xss栈大小`，单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

HotSpot JVM对栈大小的最大值和最小值有要求, Windows（64位）下的JDK8测试**最小值为180k**，**最大值为1024m**

局部变量过多、操作数栈深度过大也会影响栈内存的大小

一般情况下，工作中即便使用了递归进行操作，栈的深度最多也只能到几百,不会出现栈的溢出。所以此参数 可以手动指定为-Xss256k节省内存

### 本地方法栈

在Hotspot虚拟机中，Java虚拟机栈和本地方法栈实现上使用了**同一个栈空间**。本地方法栈会在栈内存上生成一个栈帧，临时保存方法的参数同时方便出现异常时也把本地方法的栈信息打印出来

## 堆

堆空间有三个需要关注的值，**used** **total** **max**

used指的是当前**已使用**的堆内存，total是java虚拟机**已经分配**的可用堆内存，max是java虚拟机可以分配的**最大**堆内存

随着堆中的对象增多，当total可以使用的内存即将不足时，java虚拟机会继续分配内存给堆

如果堆内存不足，java虚拟机就会不断的分配内存，total值会变大。total最多只能与max相等



**是不是当used = max = total的时候，堆内存就溢出了呢？**

不是，堆内存溢出的判断条件比较复杂，在下一章《垃圾回收器》中会详细介绍



**堆设置大小**

如果不设置任何的虚拟机参数，max默认是系统内存的1/4，total默认是系统内存的1/64。**在实际应用中一般都需要设置 total和max的值**

要修改堆的大小，可以使用虚拟机参数 –Xmx（max最大值）和-Xms (初始的total)

语法：-Xmx值 -Xms值

单位：字节（默认，必须是 1024 的倍数）、k或者K(KB)、m或者M(MB)、g或者G(GB)

限制：Xmx必须大于 2 MB，Xms必须大于1 MB

Java服务端程序开发时，**建议将-Xmx和-Xms设置为相同的值**，这样在程序启动之后可使用的总内存就是最大内存，而无 需向java虚拟机再次申请，减少了申请并分配内存时间上的开销，同时也不会出现内存过剩之后堆收缩的情况。

-Xmx具体设置的值与实际的应用程序运行环境有关，在《实战篇》中会给出设置方案

## 方法区

1.方法区是《Java虚拟机规范》中设计的**虚拟概念**，每款Java虚拟机在实现上都各不相同，Hotspot设计如下：

* **JDK7及之前**的版本将方法区存放在**堆区域中的永久代空间**，故会存在内存溢出的可能，堆的大小由虚拟机参数

  -XX:MaxPermSize=值来控制

* **JDK8及之后**的版本将方法区存放在**元空间中**，元空间位于操作系统维护的**直接内存**中，默认情况下只要不超过操作系统承受的上限，可以一直分配，可以使用-XX:MaxMetaspaceSize=值将元空间最大大小进行限制

![6e9035a9cde1e9a4777949e31cdce62](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241725830.png)



2.方法区是存放基础信息的位置，线程共享，主要包含三部分内容：**类的元信息、运行时常量池、字符串常量池**：

* 类的基本信息（元信息），一般称之为InstanceKlass对象。在类的加载阶段完成

  ![efd78585386bf13040c9f5dfa2664b1](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241715439.png)

* 运行时常量池中存放的是字节码中的常量池内容

  字节码文件中通过编号查表的方式找到常量，这种常量池称为**静态常量池**。当常量池加载到内存中之后，可以通 过内存地址快速的定位到常量池中的内容，这种常量池称为**运行时常量池**![345cf033995c07589b3ff2a696824fb](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241721328.png)

* 字符串常量池(StringTable)存储在代码中定义的常量字符串内容，比如“123”

  * 字符串常量池和运行时常量池有什么关系？

    ![99b7353760da55ac09d4863989770b2](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241733155.png)

3.静态变量的存储

JDK6及之前的版本中，静态变量是存放在方法区中的，也就是永久代：

![c629113d9cfc30a44a08b9d0164072b](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241739486.png)

JDK7及之后的版本中，静态变量是存放在堆中的Class对象中，脱离了永久代：

![6cb67350ebe3725ac1dc9b205017e05](https://cdn.jsdelivr.net/gh/hduchenshuai/PicGo_Save/picgo/202408241739608.png)